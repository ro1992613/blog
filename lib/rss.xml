<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[笔记]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://pages-9hu.pages.dev/</link><image><url>https://pages-9hu.pages.dev/lib/media/favicon.png</url><title>笔记</title><link>https://pages-9hu.pages.dev/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 16 Jul 2024 16:48:13 GMT</lastBuildDate><atom:link href="https://pages-9hu.pages.dev/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 16 Jul 2024 16:47:52 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[商务英语职场王]]></title><link>https://pages-9hu.pages.dev/知识库/英语/商务英语职场王.html</link><guid isPermaLink="false">知识库/英语/商务英语职场王.md</guid><pubDate>Tue, 16 Jul 2024 14:56:04 GMT</pubDate></item><item><title><![CDATA[Seata(原理+实战)]]></title><description><![CDATA[<br><img alt="78930f586e1de55925dec4cfbcb89429_MD5.png" src="https://pages-9hu.pages.dev/attachments/78930f586e1de55925dec4cfbcb89429_md5.png" target="_self"><br><br>分布式对应的是单体架构，互联网早起单体架构是非常流行的，好像是一个家族企业，大家在一个家里劳作，单体架构如下图：<br><img alt="559606619c6e22021604e5d2920293f7_MD5.png" src="https://pages-9hu.pages.dev/attachments/559606619c6e22021604e5d2920293f7_md5.png" target="_self"><br>但是随着业务的复杂度提高，大家族人手不够，此时不得不招人，这样逐渐演变出了分布式服务，互相协作，每个服务负责不同的业务，架构如下图：<br><img alt="6d5f5d6801046013354778154ddfb681_MD5.png" src="https://pages-9hu.pages.dev/attachments/6d5f5d6801046013354778154ddfb681_md5.png" target="_self"><br>因此需要服务与服务之间的远程协作才能完成事务，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。<br>典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。<br><br>CAP原则又叫CAP定理，同时又被称作布鲁尔定理（Brewer's theorem），指的是在一个分布式系统中，不可能同时满足以下三点。<br><img alt="848e49038fd349895055d0c8d5d94551_MD5.png" src="https://pages-9hu.pages.dev/attachments/848e49038fd349895055d0c8d5d94551_md5.png" target="_self"><br><br>指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。<br>
也就是说，在一致性系统中，一旦客户端将值写入任何一台服务器并获得响应，那么之后client从其他任何服务器读取的都是刚写入的数据
一致性保证了不管向哪台服务器写入数据，其他的服务器能实时同步数据
<br><br>可用性（高可用）是指：每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）<br><br>分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，也就是说，服务器A和B发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。<br><br>分布式系统中，必须满足 CAP 中的 P，此时只能在 C/A 之间作出取舍。<br>如果选择了CA，舍弃了P，说白了就是一个单体架构。<br><br>CAP理论告诉我们只能在C、A之间选择，在分布式事务的最终解决方案中一般选择牺牲一致性来获取可用性和分区容错性。<br>
这里的 “牺牲一致性” 并不是完全放弃数据的一致性，而是放弃强一致性而换取弱一致性。
<br>一致性可以分为以下三种：<br>
<br>强一致性
<br>弱一致性
<br>最终一致性
<br><br>系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值。<br>也称为：原子一致性（Atomic Consistency）、线性一致性（Linearizable Consistency）<br>简言之，在任意时刻，所有节点中的数据是一样的。例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。<br>总结：<br>
<br>一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务。
<br>保证了强一致性，务必会损耗可用性。
<br><br>系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。<br>但即使过了不一致时间窗口这段时间后，后续对该数据的读取也不一定是最新值。<br>所以说，可以理解为数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。<br>例如12306买火车票，虽然最后看到还剩下几张余票，但是只要选择购买就会提示没票了，这就是弱一致性。<br><br>是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。<br>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。<br>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。<br><br>弱一致性即使过了不一致时间窗口，后续的读取也不一定能保证一致，而最终一致过了不一致窗口后，后续的读取一定一致。<br>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。<br><br><br>整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。这里是属于基本可用。<br>基本可用和高可用的区别：<br>
<br>“一定时间”可以适当延长 当举行大促（比如秒杀）时，响应时间可以适当延长
<br>给部分用户返回一个降级页面 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。
<br><br>称为柔性状态，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。<br><br>同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。<br><br>在分布式架构下，每个节点只知晓自己操作的失败或者成功，无法得知其他节点的状态。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。<br><br>二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理。<br>两个阶段分别为：<br>
<br>准备阶段
<br>提交阶段
<br>参与的角色：<br>
<br>事务协调者（事务管理器）：事务的发起者
<br>事务参与者（资源管理器）：事务的执行者
<br>准备阶段（投票阶段）<br>这是两阶段的第一段，这一阶段只是准备阶段，由事务的协调者发起询问参与者是否可以提交事务，但是这一阶段并未提交事务，流程图如下图：<br><img alt="1af67ab6184f02bd543ecbab76cd0ae5_MD5.png" src="https://pages-9hu.pages.dev/attachments/1af67ab6184f02bd543ecbab76cd0ae5_md5.png" target="_self"><br>
<br>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复
<br>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）
<br>如参与者执行成功，给协调者反馈同意，否则反馈中止
<br>提交阶段<br>这一段阶段属于2PC的第二阶段（提交 执行阶段），协调者发起正式提交事务的请求，当所有参与者都回复同意时，则意味着完成事务，流程图如下：<br><img alt="d32969e620ae7c3593395f0d6d2e7fb4_MD5.png" src="https://pages-9hu.pages.dev/attachments/d32969e620ae7c3593395f0d6d2e7fb4_md5.png" target="_self"><br>
<br>协调者节点向所有参与者节点发出正式提交(commit)的请求。
<br>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
<br>参与者节点向协调者节点发送ack完成消息。
<br>协调者节点收到所有参与者节点反馈的ack完成消息后，完成事务。
<br>但是如果任意一个参与者节点在第一阶段返回的消息为终止，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时，那么这个事务将会被回滚，回滚的流程图如下：<br><img alt="e30ef92d08f6ad1dc653a23140643227_MD5.png" src="https://pages-9hu.pages.dev/attachments/e30ef92d08f6ad1dc653a23140643227_md5.png" target="_self"><br>
<br>协调者节点向所有参与者节点发出回滚操作(rollback)的请求。
<br>参与者节点利用阶段1写入的undo信息执行回滚，并释放在整个事务期间内占用的资源。
<br>参与者节点向协调者节点发送ack回滚完成消息。
<br>协调者节点受到所有参与者节点反馈的ack回滚完成消息后，取消事务。
<br>不管最后结果如何，第二阶段都会结束当前事务。 <br>二阶段提交的事务正常提交的完整流程如下图：<br><img alt="b04fed853f1c68c6660c9415aabac300_MD5.png" src="https://pages-9hu.pages.dev/attachments/b04fed853f1c68c6660c9415aabac300_md5.png" target="_self"><br>二阶段提交事务回滚的完整流程如下图：<br><img alt="812c084446dc20bc88b03fcab08cb5d2_MD5.png" src="https://pages-9hu.pages.dev/attachments/812c084446dc20bc88b03fcab08cb5d2_md5.png" target="_self"><br>举个百米赛跑的例子来具体描述下2PC的流程：学校运动会，有三个同学，分别是A，B，C，2PC流程如下：<br>
<br>裁判：A同学准备好了吗？准备进入第一赛道....
<br>裁判：B同学准备好了吗？准备进入第一赛道....
<br>裁判：C同学准备好了吗？准备进入第一赛道....
<br>如果有任意一个同学没准备好，则裁判下达回滚指令
<br>如果裁判收到了所有同学的OK回复，则再次下令跑......
<br>裁判：1,2,3 跑............
<br>A同学冲刺到终点，汇报给裁判
<br>B，C同学冲刺失败，汇报给裁判
<br>2PC的缺点<br>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：<br>
<br>性能问题：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
<br>可靠性问题：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。
<br>数据一致性问题：二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
<br>实现复杂：牺牲了可用性，对性能影响较大，不适合高并发高性能场景。
<br>2PC的优点<br>
<br>尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）
<br><br>三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点。<br>
<br>在协调者和参与者中都引入超时机制
<br>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
<br>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。处理流程如下：<br><img alt="cca8a290d6b51d979a48966f34889c6e_MD5.png" src="https://pages-9hu.pages.dev/attachments/cca8a290d6b51d979a48966f34889c6e_md5.png" target="_self"><br>阶段一：CanCommit阶段<br>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。<br>
<br>事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。
<br>响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。
<br>CanCommit阶段流程如下图：<br><img alt="2be135fd3c970973fd25206d05796d80_MD5.png" src="https://pages-9hu.pages.dev/attachments/2be135fd3c970973fd25206d05796d80_md5.png" target="_self"><br>阶段二：PreCommit阶段<br>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。<br>
<br>假如所有参与者均反馈 yes，协调者预执行事务。 <br>发送预提交请求 ：协调者向参与者发送PreCommit请求，并进入准备阶段
<br>事务预提交 ：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中（但不提交事务）
<br>响应反馈 ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。 <br><img alt="370c57a336a126ddcc35fb025024d680_MD5.png" src="https://pages-9hu.pages.dev/attachments/370c57a336a126ddcc35fb025024d680_md5.png" target="_self"><br>
<br>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。 <br>发送中断请求 ：协调者向所有参与者发送abort请求。
<br>中断事务 ：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 <br><img alt="18be0ab90575173a01dc535539a7b6a8_MD5.png" src="https://pages-9hu.pages.dev/attachments/18be0ab90575173a01dc535539a7b6a8_md5.png" target="_self"><br>阶段三：doCommit阶段<br>该阶段进行真正的事务提交，也可以分为以下两种情况。<br>
进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。
<br>
<br>执行提交 <br>发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
<br>事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
<br>响应反馈 事务提交完之后，向协调者发送ack响应。
<br>完成事务 协调者接收到所有参与者的ack响应之后，完成事务。 <br><img alt="d6ef34061a0c7e9b5456715a7f1251f6_MD5.png" src="https://pages-9hu.pages.dev/attachments/d6ef34061a0c7e9b5456715a7f1251f6_md5.png" target="_self"><br>
<br>中断事务：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务 <br>发送中断请求 如果协调者处于工作状态，向所有参与者发出 abort 请求
<br>事务回滚 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
<br>反馈结果 参与者完成事务回滚之后，向协调者反馈ACK消息
<br>中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。 <br><img alt="04c97703a5b632cc9f334db8046a8312_MD5.png" src="https://pages-9hu.pages.dev/attachments/04c97703a5b632cc9f334db8046a8312_md5.png" target="_self"><br>优点<br>相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。<br>缺点<br>数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。<br><br>TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。<br>TCC分为两个阶段，分别如下：<br>
<br>第一阶段：Try（尝试），主要是对业务系统做检测及资源预留 (加锁，锁住资源)
<br>第二阶段：本阶段根据第一阶段的结果，决定是执行confirm还是cancel <br>Confirm（确认）：执行真正的业务（执行业务，释放锁）
<br>Cancle（取消）：是预留资源的取消（出问题，释放锁） <br><img alt="f1c9aaae151c2b6dbc1cfeaf42241a83_MD5.png" src="https://pages-9hu.pages.dev/attachments/f1c9aaae151c2b6dbc1cfeaf42241a83_md5.png" target="_self"><br>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。<br>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。<br>①Try 阶段<br>TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：<br>
<br>完成所有业务检查( 一致性 ) 。
<br>预留必须业务资源( 准隔离性 ) 。
<br>Try 尝试执行业务。
<br><img alt="8d580df2e63ffa4c77ee5b46968efac1_MD5.png" src="https://pages-9hu.pages.dev/attachments/8d580df2e63ffa4c77ee5b46968efac1_md5.png" target="_self"><br>②Confirm / Cancel 阶段<br>根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。<br>Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。<br>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作，业务如下图：<br><img alt="3410a8f279e6a165fee9b62559c49f4b_MD5.png" src="https://pages-9hu.pages.dev/attachments/3410a8f279e6a165fee9b62559c49f4b_md5.png" target="_self"><br>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。<br>Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。<br>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段，业务如下图：<br><img alt="dd3bd2f6bb3b42a313cb65b674189dd1_MD5.png" src="https://pages-9hu.pages.dev/attachments/dd3bd2f6bb3b42a313cb65b674189dd1_md5.png" target="_self"><br>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。<br>最终一致性保证<br>
<br>TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。
<br>Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。也就是说只要Try成功，Confirm一定成功（TCC设计之初的定义） 。
<br>Confirm与Cancel如果失败，由TCC框架进行重试补偿
<br>存在极低概率在CC环节彻底失败，则需要定时任务或人工介入
<br>方案总结<br>TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：<br>
<br>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。
<br>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。
<br>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。
<br>缺点：<br>
<br>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。
<br><br>本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。<br>角色：<br>
<br>事务主动方
<br>事务被动方
<br>通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。<br>这样可以避免以下两种情况导致的数据不一致性：<br>
<br>业务处理成功、事务消息发送失败
<br>业务处理失败、事务消息发送成功
<br>整体的流程如下图：<br><img alt="1be4f61443d6497ea69dbf4c3237ab20_MD5.png" src="https://pages-9hu.pages.dev/attachments/1be4f61443d6497ea69dbf4c3237ab20_md5.png" target="_self"><br>上图中整体的处理步骤如下：<br>
<br>①：事务主动方在同一个本地事务中处理业务和写消息表操作
<br>②：事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。
<br>③：事务被动方通过消息中间件，通知事务主动方事务已处理的消息。
<br>④：事务主动方接收中间件的消息，更新消息表的状态为已处理。
<br>一些必要的容错处理如下：<br>
<br>当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可
<br>当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。
<br>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务
<br>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。
<br>优点<br>
<br>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。
<br>方案轻量，容易实现。
<br>缺点<br>
<br>与具体的业务场景绑定，耦合性强，不可公用。
<br>消息数据与业务数据同库，占用业务系统资源。
<br>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。
<br><br>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。<br>MQ事务方案整体流程和本地消息表的流程很相似，如下图：<br><img alt="97890b537c5f3e4d4ba8fb2613f26f0c_MD5.png" src="https://pages-9hu.pages.dev/attachments/97890b537c5f3e4d4ba8fb2613f26f0c_md5.png" target="_self"><br>从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。<br>那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。<br>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：<br>正常情况：事务主动方发消息<br><img alt="a6e9438222ae4c19b6dde1224d474bfc_MD5.png" src="https://pages-9hu.pages.dev/attachments/a6e9438222ae4c19b6dde1224d474bfc_md5.png" target="_self"><br>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：<br>
<br>步骤①：发送方向 MQ 服务端(MQ Server)发送 half 消息。
<br>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。
<br>步骤③：发送方开始执行本地事务逻辑。
<br>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。
<br>步骤⑤：MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。
<br>异常情况：事务主动方消息恢复<br><img alt="dc084a22d39b8067316fdf4f2ef6de8b_MD5.png" src="https://pages-9hu.pages.dev/attachments/dc084a22d39b8067316fdf4f2ef6de8b_md5.png" target="_self"><br>在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：<br>
<br>步骤⑤：MQ Server 对该消息发起消息回查。
<br>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
<br>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。
<br>步骤⑧：MQ Server基于 commit/rollback 对消息进行投递或者删除。
<br>优点<br>相比本地消息表方案，MQ 事务方案优点是：<br>
<br>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。
<br>吞吐量大于使用本地消息表方案。
<br>缺点<br>
<br>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。
<br>业务处理服务需要实现消息状态回查接口。
<br><br>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。<br>最大努力通知的整体流程如下图：<br><img alt="92b60eb4b92dffd21591574e087d3d4f_MD5.png" src="https://pages-9hu.pages.dev/attachments/92b60eb4b92dffd21591574e087d3d4f_md5.png" target="_self"><br>在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；<br>但是最大努力通知，事务主动方尽最大努力（重试，轮询....）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。<br>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。<br><br>Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文。<br>Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。<br>Saga 事务基本协议如下：<br>
<br>每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。
<br>每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。
<br>TCC事务补偿机制有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；Saga事务没有预留动作，直接提交。<br>对于事务异常，Saga提供了两种恢复策略，分别如下：<br>向后恢复(backward recovery)<br>在执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式。如下图：<br><img alt="aa632782069cd3b3e408acc555049f85_MD5.png" src="https://pages-9hu.pages.dev/attachments/aa632782069cd3b3e408acc555049f85_md5.png" target="_self"><br>从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿。<br>对应的执行顺序为：T1,T2,T3,C3,C2,C1<br>这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。<br>向前恢复(forward recovery)<br>也称之为：勇往直前，对于执行不通过的事务，会尝试重试事务，这里有一个假设就是每个子事务最终都会成功。<br>流程如下图：<br><img alt="7f3b6bd881cfc9733c065b97eed79a34_MD5.png" src="https://pages-9hu.pages.dev/attachments/7f3b6bd881cfc9733c065b97eed79a34_md5.png" target="_self"><br>适用于必须要成功的场景，事务失败了重试，不需要补偿。<br>Saga事务有两种不同的实现方式，分别如下：<br>
<br>命令协调（Order Orchestrator）
<br>事件编排（Event Choreographyo）
<br>命令协调<br>中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：<br><img alt="c8bc77671bf54ca3e57ab4e58c3727a1_MD5.png" src="https://pages-9hu.pages.dev/attachments/c8bc77671bf54ca3e57ab4e58c3727a1_md5.png" target="_self"><br>上图步骤如下：<br>
<br>事务发起方的主业务逻辑请求 OSO 服务开启订单事务
<br>OSO 向库存服务请求扣减库存，库存服务回复处理结果。
<br>OSO 向订单服务请求创建订单，订单服务回复创建结果。
<br>OSO 向支付服务请求支付，支付服务回复处理结果。
<br>主业务逻辑接收并处理 OSO 事务处理结果回复。
<br>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。<br>基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。<br>事件编排<br>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。<br>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。<br>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。<br><img alt="ade824bd58c6dfcdde2f95d13ef4beed_MD5.png" src="https://pages-9hu.pages.dev/attachments/ade824bd58c6dfcdde2f95d13ef4beed_md5.png" target="_self"><br>上图步骤如下：<br>
<br>事务发起方的主业务逻辑发布开始订单事件。
<br>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。
<br>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。
<br>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。
<br>主业务逻辑监听订单已支付事件并处理。
<br>事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。<br>优点<br>命令协调设计的优点如下：<br>
<br>服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。
<br>程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
<br>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。
<br>事件/编排设计优点如下：<br>
<br>避免中央协调器单点故障风险。
<br>当涉及的步骤较少服务开发简单，容易实现。
<br>缺点<br>命令协调设计缺点如下：<br>
<br>中央协调器容易处理逻辑容易过于复杂，导致难以维护。
<br>存在协调器单点故障风险。
<br>事件/编排设计缺点如下：<br>
<br>服务之间存在循环依赖的风险。
<br>当涉及的步骤较多，服务间关系混乱，难以追踪调测。
<br>
由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性。
<br>当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。<br><br>总结一下各个方案的常见的使用场景：<br>
<br>2PC/3PC：依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。
<br>TCC：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。
<br>本地消息表/MQ 事务：都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。
<br>Saga 事务：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。
<br>上面讲了这么多的分布式事务的理论知识，都没看到一个落地的实现，这不是吹牛逼吗？<br><br>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。<br>
<br>对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入
<br>高性能：减少分布式事务解决方案所带来的性能消耗
<br>官方文档：<a data-tooltip-position="top" aria-label="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fseata.io%252Fzh-cn%252Findex.html%26login%3Dfrom_csdn" rel="noopener" class="external-link is-unresolved" title="seata.io/zh-cn/index…" href="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fseata.io%252Fzh-cn%252Findex.html%26login%3Dfrom_csdn" target="_self">seata.io/zh-cn/index…</a><br>seata的几种术语：<br>
<br>TC（Transaction Coordinator）：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。
<br>TM（Transaction Manager）：事务管理者。用于开启、提交或回滚事务。
<br>RM（Resource Manager）：资源管理器。用于分支事务上的资源管理，向 TC 注册分支事务，上报分支事务的状态，接收 TC 的命令来提交或者回滚分支事务。
<br><br>seata目前支持多种事务模式，分别有AT、TCC、SAGA 和 XA ，文章篇幅有限，今天只讲常用的AT模式。<br>AT模式的特点就是对业务无入侵式，整体机制分二阶段提交（2PC）<br>
<br>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
<br>二阶段： <br>提交异步化，非常快速地完成
<br>回滚通过一阶段的回滚日志进行反向补偿。 <br>在 AT 模式下，用户只需关注自己的业务SQL，用户的业务SQL 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。<br><img alt="a20eec564d4dbcfb2367e4f8ba689da1_MD5.png" src="https://pages-9hu.pages.dev/attachments/a20eec564d4dbcfb2367e4f8ba689da1_md5.png" target="_self"><br>一个典型的分布式事务过程：<br>
<br>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；
<br>XID 在微服务调用链路的上下文中传播；
<br>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；
<br>TM 向 TC 发起针对 XID 的全局提交或回滚决议；
<br>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。
<br><br>seata的协调者其实就是阿里开源的一个服务，我们只需要下载并且启动它。<br>下载地址：<a data-tooltip-position="top" aria-label="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttp%253A%252F%252Fseata.io%252Fzh-cn%252Fblog%252Fdownload.html%26login%3Dfrom_csdn" rel="noopener" class="external-link is-unresolved" title="seata.io/zh-cn/blog/…" href="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttp%253A%252F%252Fseata.io%252Fzh-cn%252Fblog%252Fdownload.html%26login%3Dfrom_csdn" target="_self">seata.io/zh-cn/blog/…</a><br>
陈某下载的版本是1.3.0 ，各位最好和我版本一致，这样不会出现莫名的BUG。
<br>下载完成后，直接解压即可。但是此时还不能直接运行，还需要做一些配置。<br><br>TC运行需要将事务的信息保存在数据库，因此需要创建一些表，找到seata-1.3.0源码的script\server\db这个目录，将会看到以下SQL文件：<br><img alt="7c35e215fa1eabd9cd841ba8d4cc2b1e_MD5.png" src="https://pages-9hu.pages.dev/attachments/7c35e215fa1eabd9cd841ba8d4cc2b1e_md5.png" target="_self"><br>陈某使用的是Mysql数据库，因此直接运行mysql.sql这个文件中的sql语句，创建的三张表如下图：<br><img alt="20ab2ea44b2cfadfebe5e70668a13406_MD5.png" src="https://pages-9hu.pages.dev/attachments/20ab2ea44b2cfadfebe5e70668a13406_md5.png" target="_self"><br><br>找到seata-server-1.3.0\seata\conf这个目录，其中有一个registry.conf文件，其中配置了TC的注册中心和配置中心。<br>默认的注册中心是file形式，实际使用中肯定不能使用，需要改成Nacos形式，改动的地方如下图：<br><img alt="c73b6d31fb71aabcce7c501320d0ad95_MD5.png" src="https://pages-9hu.pages.dev/attachments/c73b6d31fb71aabcce7c501320d0ad95_md5.png" target="_self"><br>需要改动的地方如下：<br>
<br>type：改成nacos，表示使用nacos作为注册中心
<br>application：服务的名称
<br>serverAddr：nacos的地址
<br>group：分组
<br>namespace：命名空间
<br>username：用户名
<br>password：密码
<br>
最后这份文件都会放在项目源码的根目录下，源码下载方式见文末
<br><br>TC的配置中心默认使用的也是file形式，当然要是用nacos作为配置中心了。<br>直接修改registry.conf文件，需要改动的地方如下图：<br><img alt="f1b1baeaff46e411ac2a79bedb83f4dd_MD5.png" src="https://pages-9hu.pages.dev/attachments/f1b1baeaff46e411ac2a79bedb83f4dd_md5.png" target="_self"><br>需要改动的地方如下：<br>
<br>type：改成nacos，表示使用nacos作为配置中心
<br>serverAddr：nacos的地址
<br>group：分组
<br>namespace：命名空间
<br>username：用户名
<br>password：密码
<br>上述配置修改好之后，在TC启动的时候将会自动读取nacos的配置。<br>那么问题来了：TC需要存储到Nacos中的配置都哪些，如何推送过去？<br>在seata-1.3.0\script\config-center中有一个config.txt文件，其中就是TC所需要的全部配置。<br>在seata-1.3.0\script\config-center\nacos中有一个脚本nacos-config.sh则是将config.txt中的全部配置自动推送到nacos中，运行下面命令（windows可以使用git bash运行）：<br>$ sh nacos-config.sh -h 127.0.0.1 -p 8080 -g SEATA_GROUP -t 7a7581ef-433d-46f3-93f9-5fdc18239c65 -u nacos -w nacos
复制代码
复制<br>推送成功则可以在Nacos中查询到所有的配置，如下图：<br><img alt="d0a931e384624de5f757b3dcaf563333_MD5.png" src="https://pages-9hu.pages.dev/attachments/d0a931e384624de5f757b3dcaf563333_md5.png" target="_self"><br><br>TC是需要使用数据库存储事务信息的，那么如何修改相关配置呢？<br>上一节的内容已经将所有的配置信息都推送到了Nacos中，TC启动时会从Nacos中读取，因此我们修改也需要在Nacos中修改。<br>需要修改的配置如下：<br>store.mode=db store.db.datasource=druid store.db.dbType=mysql store.db.driverClassName=com.mysql.jdbc.Driver store.db.url=jdbc:mysql://127.0.0.1:3306/seata_server?useUnicode=true store.db.user=root store.db.password=Nov2014
复制代码
复制<br>在nacos中搜索上述的配置，直接修改其中的值，比如修改store.mode，如下图：<br><img alt="2fb4c2b60b370e31f495258e7815797b_MD5.png" src="https://pages-9hu.pages.dev/attachments/2fb4c2b60b370e31f495258e7815797b_md5.png" target="_self"><br>当然Seata还支持Redis作为TC的数据库，只需要改动以下配置即可：<br>store.mode=redis
store.redis.host=127.0.0.1
store.redis.port=6379
store.redis.password=123456
复制代码
复制<br><br>按照上述步骤全部配置成功后，则可以启动TC，在seata-server-1.3.0\seata\bin目录下直接点击seata-server.bat（windows）运行。<br>启动成功后，在Nacos的服务列表中则可以看到TC已经注册进入，如下图：<br><img alt="f72cb2b1f4728b2a71e00274ff8c2404_MD5.png" src="https://pages-9hu.pages.dev/attachments/f72cb2b1f4728b2a71e00274ff8c2404_md5.png" target="_self"><br>至此，Seata的TC就启动完成了............<br><br>上述已经将Seata的服务端（TC）搭建完成了，下面就以电商系统为例介绍一下如何编码实现分布式事务。<br>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：<br>
<br>仓储服务：对给定的商品扣除仓储数量。
<br>订单服务：根据采购需求创建订单。
<br>帐户服务：从用户帐户中扣除余额。
<br>需要了解的知识：Nacos和openFeign，有不清楚的可以看我的前两章教程，如下：<br>
<br><a data-tooltip-position="top" aria-label="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzU3MDAzNDg1MA%253D%253D%2526mid%253D2247493854%2526idx%253D1%2526sn%253D4b3fb7f7e17a76000733899f511ef915%2526scene%253D21%2523wechat_redirect%26login%3Dfrom_csdn" rel="noopener" class="external-link is-unresolved" title="五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？" href="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzU3MDAzNDg1MA%253D%253D%2526mid%253D2247493854%2526idx%253D1%2526sn%253D4b3fb7f7e17a76000733899f511ef915%2526scene%253D21%2523wechat_redirect%26login%3Dfrom_csdn" target="_self">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a>
<br><a data-tooltip-position="top" aria-label="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzU3MDAzNDg1MA%253D%253D%2526mid%253D2247496653%2526idx%253D1%2526sn%253D7185077b3bdc1d094aef645d677ec472%2526scene%253D21%2523wechat_redirect%26login%3Dfrom_csdn" rel="noopener" class="external-link is-unresolved" title="openFeign夺命连环9问，这谁受得了？" href="https://link.csdn.net/?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%253F__biz%253DMzU3MDAzNDg1MA%253D%253D%2526mid%253D2247496653%2526idx%253D1%2526sn%253D7185077b3bdc1d094aef645d677ec472%2526scene%253D21%2523wechat_redirect%26login%3Dfrom_csdn" target="_self">openFeign夺命连环9问，这谁受得了？</a>
<br><br>陈某整个教程使用的都是同一个聚合项目，关于Spring Cloud版本有不清楚的可以看我第一篇文章的说明。<br>添加依赖<br>新建一个seata-storage9020项目，新增依赖如下：<br><img alt="13347cfe30aa2731b5a7ce0c71b37e88_MD5.png" src="https://pages-9hu.pages.dev/attachments/13347cfe30aa2731b5a7ce0c71b37e88_md5.png" target="_self"><br>由于使用的springCloud Alibaba依赖版本是2.2.1.RELEASE，其中自带的seata版本是1.1.0，但是我们Seata服务端使用的版本是1.3.0，因此需要排除原有的依赖，重新添加1.3.0的依赖。<br>
注意：seata客户端的依赖版本必须要和服务端一致。
<br>创建数据库<br>创建一个数据库seata-storage，其中新建两个表：<br>
<br>storage：库存的业务表，SQL如下：
<br>CREATE TABLE `storage` ( \`id\` bigint(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4\_general\_ci NULL DEFAULT NULL, \`num\` bigint(11) NULL DEFAULT NULL COMMENT '数量', \`create_time\` datetime(0) NULL DEFAULT NULL, \`price\` bigint(10) NULL DEFAULT NULL COMMENT '单价，单位分', PRIMARY KEY (\`id\`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4\_general\_ci ROW_FORMAT = Compact; INSERT INTO `storage` VALUES (1, '码猿技术专栏', 1000, '2021-10-15 22:32:40', 100);
复制代码
复制<br>
<br>undo_log：回滚日志表，这是Seata要求必须有的，每个业务库都应该创建一个，SQL如下：
<br>CREATE TABLE \`undo_log\` ( \`branch_id\` bigint(20) NOT NULL COMMENT 'branch transaction id', \`xid\` varchar(100) CHARACTER SET utf8 COLLATE utf8\_general\_ci NOT NULL COMMENT 'global transaction id', \`context\` varchar(128) CHARACTER SET utf8 COLLATE utf8\_general\_ci NOT NULL COMMENT 'undo_log context,such as serialization', \`rollback_info\` longblob NOT NULL COMMENT 'rollback info', \`log_status\` int(11) NOT NULL COMMENT '0:normal status,1:defense status', \`log_created\` datetime(6) NOT NULL COMMENT 'create datetime', \`log_modified\` datetime(6) NOT NULL COMMENT 'modify datetime', UNIQUE INDEX \`ux\_undo\_log\`(\`xid\`, \`branch_id\`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8\_general\_ci COMMENT = 'AT transaction mode undo table' ROW_FORMAT = Compact;
复制代码
复制<br>配置seata相关配置<br>对于Nacos、Mysql数据源等相关信息就省略了，项目源码中都有。主要讲一下seata如何配置，详细配置如下：<br>spring: application: name: seata-storage seata: enabled: true application-id: ${spring.application.name} tx-service-group: ${spring.application.name}-tx-group config: type: nacos nacos: namespace: 7a7581ef-433d-46f3-93f9-5fdc18239c65 server-addr: localhost:8848 group: SEATA_GROUP username: nacos password: nacos registry: type: nacos nacos: application: seata-server group: SEATA_GROUP namespace: 7a7581ef-433d-46f3-93f9-5fdc18239c65 username: nacos password: nacos server-addr: localhost:8848
复制代码
复制<br>以上配置注释已经很清楚，这里着重强调以下几点：<br>
<br>客户端seata中的nacos相关配置要和服务端相同，比如地址、命名空间..........
<br>tx-service-group：这个属性一定要注意，这个一定要和服务端的配置一致，否则不生效；比如上述配置中的，就要在nacos中新增一个配置service.vgroupMapping.seata-storage-tx-group=default，如下图：
<br><img alt="0ba432de42f3e76494cb126798806b34_MD5.png" src="https://pages-9hu.pages.dev/attachments/0ba432de42f3e76494cb126798806b34_md5.png" target="_self"><br>
注意：seata-storage-tx-group仅仅是后缀，要记得添加配置的时候要加上前缀service.vgroupMapping.
<br>扣减库存的接口<br>逻辑很简单，这里仅仅是做了减库存的操作，代码如下：<br><img alt="3a1804a0e286a8b6a127ec694319ebd9_MD5.png" src="https://pages-9hu.pages.dev/attachments/3a1804a0e286a8b6a127ec694319ebd9_md5.png" target="_self"><br>这里的接口并没有不同，还是使用@Transactional开启了本地事务，并没有涉及到分布式事务。<br>到这里仓储服务搭建好了..............<br><br>搭建完了仓储服务，账户服务搭建很类似了。<br>添加依赖<br>新建一个seata-account9021服务，这里的依赖和仓储服务的依赖相同，直接复制<br>创建数据库<br>创建一个seata-account数据库，其中新建了两个表：<br>
<br>account：账户业务表，SQL如下：
<br>CREATE TABLE \`account\` ( \`id\` bigint(11) NOT NULL, \`user_id\` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4\_general\_ci NULL DEFAULT NULL COMMENT '用户userId', `money` bigint(11) NULL DEFAULT NULL COMMENT '余额，单位分', \`create_time\` datetime(0) NULL DEFAULT NULL, PRIMARY KEY (\`id\`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4\_general\_ci ROW_FORMAT = Compact; INSERT INTO \`account\` VALUES (1, 'abc123', 1000, '2021-10-19 17:49:53');
复制代码
复制<br>
<br>undo_log：回滚日志表，同仓储服务
<br>配置seata相关配置<br>Seata相关配置和仓储服务相同，只不过需要在nacos中添加一个service.vgroupMapping.seata-account-tx-group=default，如下图：<br><img alt="8a67726b196b491b440a352ed784279b_MD5.png" src="https://pages-9hu.pages.dev/attachments/8a67726b196b491b440a352ed784279b_md5.png" target="_self"><br>扣减余额的接口<br>具体逻辑自己完善，这里我直接扣减余额，代码如下：<br><img alt="dd5d033965f3a919dce34f136a6c69e9_MD5.png" src="https://pages-9hu.pages.dev/attachments/dd5d033965f3a919dce34f136a6c69e9_md5.png" target="_self"><br>依然没有涉及到分布式事务，还是使用@Transactional开启了本地事务，是不是很爽............<br><br>这里为了节省篇幅，陈某直接使用订单服务作为TM，下单、减库存、扣款整个流程都在订单服务中实现。<br>添加依赖<br>新建一个seata-order9022服务，这里需要添加的依赖如下：<br>
<br>Nacos服务发现的依赖
<br>seata的依赖
<br>openFeign的依赖，由于要调用账户、仓储的微服务，因此需要额外添加一个openFeign的依赖
<br>创建数据库<br>新建一个seata_order数据库，其中新建两个表，如下：<br>
<br>t_order：订单的业务表
<br>CREATE TABLE \`t_order\` ( \`id\` bigint(11) NOT NULL AUTO_INCREMENT, \`product_id\` bigint(11) NULL DEFAULT NULL COMMENT '商品Id', \`num\` bigint(11) NULL DEFAULT NULL COMMENT '数量', \`user_id\` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4\_general\_ci NULL DEFAULT NULL COMMENT '用户唯一Id', \`create_time\` datetime(0) NULL DEFAULT NULL, \`status\` int(1) NULL DEFAULT NULL COMMENT '订单状态 1 未付款 2 已付款 3 已完成', PRIMARY KEY (\`id\`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4\_general\_ci ROW_FORMAT = Compact;
复制代码
复制<br>
<br>undo_log：回滚日志表，同仓储服务
<br>配置和seata相关配置<br>Seata相关配置和仓储服务相同，只不过需要在nacos中添加一个service.vgroupMapping.seata-order-tx-group=default，如下图：<br><img alt="77cef87de2e6e9c390d446b7dfb9264e_MD5.png" src="https://pages-9hu.pages.dev/attachments/77cef87de2e6e9c390d446b7dfb9264e_md5.png" target="_self"><br>扣减库存的接口<br>这里需要通过openFeign调用仓储服务的接口进行扣减库存，接口如下：<br><img alt="1715610e7adff8f737bd15ee9ab7c134_MD5.png" src="https://pages-9hu.pages.dev/attachments/1715610e7adff8f737bd15ee9ab7c134_md5.png" target="_self"><br>以上只是简单的通过openFeign调用，更细致的配置，比如降级，自己完善.........<br>扣减余额的接口<br>这里仍然是通过openFeign调用账户服务的接口进行扣减余额，接口如下：<br><img alt="32ed14ec5e9d1f66bb73e6b2c26477d1_MD5.png" src="https://pages-9hu.pages.dev/attachments/32ed14ec5e9d1f66bb73e6b2c26477d1_md5.png" target="_self"><br>创建订单的接口<br>下订单的接口就是一个事务发起方，作为TM，需要发起一个全局事务，详细代码如下图：<br><img alt="a4718cd7c1e7c3d8182616fb270bbf7e_MD5.png" src="https://pages-9hu.pages.dev/attachments/a4718cd7c1e7c3d8182616fb270bbf7e_md5.png" target="_self"><br>有什么不同？不同之处就是使用了@GlobalTransactional而不是@Transactional。<br>@GlobalTransactional是Seata提供的，用于开启才能全局事务，只在TM中标注即可生效。<br><br>分别启动seata-account9021、seata-storage9020、seata-order9022，如下图：<br><img alt="0867557eaac94373ff9067f0341b967f_MD5.png" src="https://pages-9hu.pages.dev/attachments/0867557eaac94373ff9067f0341b967f_md5.png" target="_self"><br>下面调用下单接口，如下图：<br><img alt="3fa34dfd69c8ec354a64830679729c68_MD5.png" src="https://pages-9hu.pages.dev/attachments/3fa34dfd69c8ec354a64830679729c68_md5.png" target="_self"><br>从控制台输出的日志可以看出，流程未出现任何异常，事务已经提交，如下图：<br><img alt="cb6bb270e70162efc15ef5e480a9ae6f_MD5.png" src="https://pages-9hu.pages.dev/attachments/cb6bb270e70162efc15ef5e480a9ae6f_md5.png" target="_self"><br>果然，查看订单、余额、库存表，数据也都是正确的。<br>但是，这仅仅是流程没问题，并不能说明分布式事务已经配置成功了，因此需要手动造个异常。<br>在扣减余额的接口睡眠2秒钟，因为openFeign的超时时间默认是1秒，这样肯定是超时异常了，如下图：<br><img alt="efd4b696fa3a63c237ff5bff7f0e4271_MD5.png" src="https://pages-9hu.pages.dev/attachments/efd4b696fa3a63c237ff5bff7f0e4271_md5.png" target="_self"><br>此时，调用创建订单的接口，控制台日志输出如下图：<br><img alt="a3f10b91dbbace0589170605280da56f_MD5.png" src="https://pages-9hu.pages.dev/attachments/a3f10b91dbbace0589170605280da56f_md5.png" target="_self"><br>发现在扣减余额处理中超时了，导致了异常.......<br>此时，看下库存的数据有没有扣减，很高兴，库存没有扣减成功，说明事务已经回滚了，分布式事务成功了。<br><br>Seata客户端创建很简单，需要注意以下几点内容：<br>
<br>seata客户端的版本需要和服务端保持一致
<br>每个服务的数据库都要创建一个undo_log回滚日志表
<br>客户端指定的事务分组名称要和Nacos相同，比如service.vgroupMapping.seata-account-tx-group=default <br>前缀：service.vgroupMapping.
<br>后缀：{自定义} <br>
项目源码已经上传，关注公众号码猿技术专栏回复关键词9528获取！
<br><br>AT模式最大的优点就是对业务代码无侵入，一切都像在写单体业务逻辑一样。<br>TC相关的三张表：<br>
<br>global_table：全局事务表，每当有一个全局事务发起后，就会在该表中记录全局事务的ID
<br>branch_table：分支事务表，记录每一个分支事务的ID，分支事务操作的哪个数据库等信息
<br>lock_table：全局锁
<br><br>
<br>TM：seata-order.create()方法执行时，由于该方法具有@GlobalTranscational标志，该TM会向TC发起全局事务，生成XID（全局锁）
<br>RM：StorageService.deduct：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果
<br>RM：AccountService.deduct()：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果
<br>RM：OrderService.create：写表，UNDO_LOG记录回滚日志（Branch ID），通知TC操作结果
<br>RM写表的过程，Seata 会拦截业务SQL，首先解析 SQL 语义，在业务数据被更新前，将其保存成before image（前置镜像），然后执行业务SQL，在业务数据更新之后，再将其保存成after image（后置镜像），最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。<br><img alt="04a21748d28efa3e300ffb4aa5442129_MD5.png" src="https://pages-9hu.pages.dev/attachments/04a21748d28efa3e300ffb4aa5442129_md5.png" target="_self"><br><br>因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。<br>正常：TM执行成功，通知TC全局提交，TC此时通知所有的RM提交成功，删除UNDO_LOG回滚日志<br><img alt="1e5554c74055522db504b870d38e2869_MD5.png" src="https://pages-9hu.pages.dev/attachments/1e5554c74055522db504b870d38e2869_md5.png" target="_self"><br>异常：TM执行失败，通知TC全局回滚，TC此时通知所有的RM进行回滚，根据UNDO_LOG反向操作，使用before image还原业务数据，删除UNDO_LOG，但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。<br><img alt="afa5f3cf209c497f630bc185005e4426_MD5.png" src="https://pages-9hu.pages.dev/attachments/afa5f3cf209c497f630bc185005e4426_md5.png" target="_self"><br>
AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写业务 SQL，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。
]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/分布式事务架构/seata(原理+实战).html</link><guid isPermaLink="false">知识库/工作技能/分布式/分布式事务架构/Seata(原理+实战).md</guid><pubDate>Mon, 15 Jul 2024 16:22:00 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/78930f586e1de55925dec4cfbcb89429_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/78930f586e1de55925dec4cfbcb89429_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[XXL-JOB轻量级分布式任务调度框架文档]]></title><description><![CDATA[<br><br><br>XXL-JOB是一个轻量级<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020" target="_self">分布式</a>任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。<br><br>1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；<br>
2、动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，即时生效；<br>
3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”基于集群Quartz实现，可保证调度中心HA；<br>
4、执行器HA（分布式）：任务分布式执行，任务"执行器"支持集群部署，可保证任务执行HA；<br>
5、任务Failover：执行器集群部署时，任务路由策略选择"故障转移"情况下调度失败时将会平滑切换执行器进行Failover；<br>
6、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；<br>
7、自定义任务参数：支持在线配置调度任务入参，即时生效；<br>
8、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；<br>
9、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；<br>
10、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；<br>
11、状态监控：支持实时监控任务进度；<br>
12、Rolling执行日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；<br>
13、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。<br>
14、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；<br>
15、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；<br>
16、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;<br>
17、任务注册: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；<br>
18、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；<br>
19、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；<br>
20、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python等类型脚本;<br>
21、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；<br>
22、失败处理策略；调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；<br>
23、分片广播任务：执行器集群部署时，任务路由策略选择"分片广播"情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；<br>
24、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。<br>
25、事件触发：除了"Cron方式"和"任务依赖方式"触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。<br><br>于2015年中，github上创建XXL-JOB项目仓库并提交第一个commit，随之进行系统结构设计，UI选型，交互设计……<br>
于2015-11月，XXL-JOB终于RELEASE了第一个大版本V1.0， 随后我将之发布到OSCHINA，XXL-JOB在OSCHINA上获得了@红薯的热门推荐，同期分别达到了OSCHINA的“热门动弹”排行第一和git.oschina的开源软件月热度排行第一，在此特别感谢红薯，感谢大家的关注和支持。<br>
于2015-12月，我将XXL-JOB发表到我司内部知识库，并且得到内部同事认可。<br>
于2016-01月，我司展开XXL-JOB的内部接入和定制工作，在此感谢袁某和尹某两位同事的贡献，同时也感谢内部其他给与关注与支持的同事。<br>
于2017-05-13，在上海举办的 “第62期开源中国源创会” 的 “放码过来” 环节，我登台对XXL-JOB做了演讲，台下五百位在场观众反响热烈（图文回顾 ）。<br>
我司大众点评目前已接入XXL-JOB，内部别名《Ferrari》（Ferrari基于XXL-JOB的V1.1版本定制而成，新接入应用推荐升级最新版本）。 据最新统计, 自2016-01-21接入至2017-07-07期间，该系统已调度约60万余次，表现优异。新接入应用推荐使用最新版本，因为经过数个大版本的更新，系统的任务模型、UI交互模型以及底层调度通讯模型都有了较大的优化和提升，核心功能更加稳定高效。<br>
至今，XXL-JOB已接入多家公司的线上产品线，接入场景如电商业务，O2O业务和大数据作业等。<br>1.4 下载<br>
文档地址<br>
中文文档<br>
English Documentation<br>
源码仓库地址<br>
English Documentation<br>
源码仓库地址<br>
源码仓库地址 Release Download<br>
<a rel="noopener" class="external-link is-unresolved" href="https://github.com/xuxueli/xxl-job" target="_self">https://github.com/xuxueli/xxl-job</a> Download<br>
<a rel="noopener" class="external-link is-unresolved" href="http://git.oschina.net/xuxueli0323/xxl-job" target="_self">http://git.oschina.net/xuxueli0323/xxl-job</a> Download<br>
中央仓库地址<br>`&lt;!-- http://repo1.maven.org/maven2/com/xuxueli/xxl-job-core/ --&gt;
&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;
&lt;/dependency&gt;` 复制<br><br>JDK：1.7+<br>
Servlet/JSP Spec：3.1/2.3<br>
Tomcat：8.5.x/Jetty9.2.x<br>
Spring-boot：1.5.x/Spring4.x<br>
Mysql：5.6+<br>
Maven：3+<br><br><br>请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可，正常情况下应该生成16张表。<br>
“调度数据库初始化SQL脚本” 位置为:<br>
/xxl-job/doc/db/tables_xxl_job.sql<br>
调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例;<br>
如果mysql做主从,调度中心集群节点务必强制走主库;<br><br>解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：<br>
xxl-job-admin：调度中心<br>
xxl-job-core：公共依赖<br>
xxl-job-executor：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）<br>
：xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用，推荐这种方式；<br>
：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器；<br>
：xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器；<br><br>调度中心项目：xxl-job-admin<br>
作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。<br>
步骤一：调度中心配置：<br>
调度中心配置文件地址：<br>`/xxl-job/xxl-job-admin/src/main/resources/xxl-job-admin.properties` 复制<br>调度中心配置内容说明：<br>`### 调度中心JDBC链接：链接地址请保持和 2.1章节 所创建的调度数据库的地址一致
xxl.job.db.driverClass=com.mysql.jdbc.Driver
xxl.job.db.url=jdbc:mysql://localhost:3306/xxl-job?useUnicode=true&amp;characterEncoding=UTF-8
xxl.job.db.user=root
xxl.job.db.password=root_pwd ### 报警邮箱
xxl.job.mail.host=smtp.163.com
xxl.job.mail.port=25
xxl.job.mail.username=ovono802302@163.com
xxl.job.mail.password=asdfzxcv
xxl.job.mail.sendFrom=ovono802302@163.com
xxl.job.mail.sendNick=《任务调度平台XXL-JOB》 ### 登录账号
xxl.job.login.username=admin
xxl.job.login.password=123456
### 调度中心通讯TOKEN，非空时启用
xxl.job.accessToken=` 复制<br>步骤二：部署项目：<br>
如果已经正确进行上述配置，可将项目编译打war包并部署到tomcat中。 调度中心访问地址：<a rel="noopener" class="external-link is-unresolved" href="http://localhost:8080/xxl-job-admin" target="_self">http://localhost:8080/xxl-job-admin</a> (该地址执行器将会使用到，作为回调地址)，登录后运行界面如下图所示<br>
<img alt="63ef3ef2cea1ad8667df2b885a676c6f_MD5.png" src="https://pages-9hu.pages.dev/attachments/63ef3ef2cea1ad8667df2b885a676c6f_md5.png" target="_self"><br>至此“调度中心”项目已经部署成功。<br>
步骤三：调度中心集群（可选）：<br>
调度中心支持集群部署，提升调度系统可用性。<br>
集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。<br>
调度中心在集群部署时可通过nginx负载均衡，此时可以为集群分配一个域名。该域名一方面可以用于访问，另一方面也可以用于配置执行器回调地址。<br><br>“执行器”项目：xxl-job-executor-sample-spring (如新建执行器项目，可参考该Sample示例执行器项目的配置步骤；)<br>
作用：负责接收“调度中心”的调度并执行；可直接部署执行器，也可以将执行器集成到现有业务项目中。<br>
步骤一：maven依赖<br>
确认pom文件中引入了 “xxl-job-core” 的maven依赖；<br>
步骤二：执行器配置<br>
执行器配置，配置文件地址：<br>`/xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-spring/src/main/resources/xxl-job-executor.properties` 复制<br>执行器配置，配置内容说明：<br>`### xxl-job admin address list：调度中心部署跟地址：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行"执行器心跳注册"和"任务结果回调"。
xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin ### xxl-job executor address：执行器"AppName"和地址信息配置：AppName执行器心跳注册分组依据；地址信息用于"调度中心请求并触发任务"和"执行器注册"。执行器默认端口为9999，执行器IP默认为空表示自动获取IP，多网卡时可手动设置指定IP，手动设置IP时将会绑定Host。单机部署多个执行器时，注意要配置不同执行器端口；
xxl.job.executor.appname=xxl-job-executor-sample
xxl.job.executor.ip=
xxl.job.executor.port=9999 ### xxl-job log path：执行器运行日志文件存储的磁盘位置，需要对该路径拥有读写权限
xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler/ ### xxl-job, access token：执行器通讯TOKEN，非空时启用
xxl.job.accessToken=` 复制<br>步骤三：执行器组件配置<br>
执行器组件，配置文件地址：<br>`/xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-spring/src/main/resources/applicationcontext-xxl-job.xml` 复制<br>执行器组件，配置内容说明：<br>`&lt;!-- 配置01、JobHandler 扫描路径：自动扫描容器中JobHandler --&gt;
&lt;context:component-scan base-package="com.xxl.job.executor.service.jobhandler" /&gt; &lt;!-- 配置02、执行器Excutor配置：执行器核心配置 --&gt;
&lt;bean id="xxlJobExecutor" class="com.xxl.job.core.executor.XxlJobExecutor" init-method="start" destroy-method="destroy" &gt; &lt;!-- 执行器IP[选填]，为空则自动获取 --&gt; &lt;property name="ip" value="${xxl.job.executor.ip}" /&gt; &lt;!-- 执行器端口号[必须] --&gt; &lt;property name="port" value="${xxl.job.executor.port}" /&gt; &lt;!-- 执行器AppName[选填]，为空则关闭自动注册 --&gt; &lt;property name="appName" value="${xxl.job.executor.appname}" /&gt; &lt;!-- 执行器注册中心地址[选填]，为空则关闭自动注册 --&gt; &lt;property name="adminAddresses" value="${xxl.job.admin.addresses}" /&gt; &lt;!-- 执行器日志路径[必填] --&gt; &lt;property name="logPath" value="${xxl.job.executor.logpath}" /&gt; &lt;!-- 访问令牌，非空则进行匹配校验[选填] --&gt; &lt;property name="accessToken" value="${xxl.job.accessToken}" /&gt;
&lt;/bean&gt;` 复制<br>步骤四：部署执行器项目：<br>
如果已经正确进行上述配置，可将执行器项目编译打部署，系统提供三个执行器Sample示例项目，选择其中一个即可，各自的部署方式如下。<br>`xxl-job-executor-sample-spring：项目编译打包成WAR包，并部署到tomcat中。
xxl-job-executor-sample-springboot：项目编译打包成springboot类型的可执行JAR包，命令启动即可；` 复制<br>至此“执行器”项目已经部署结束。<br>
步骤五：执行器集群（可选）：<br>
执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。<br>
集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。<br><br>本示例以新建一个 “GLUE模式(Java)” 运行模式的任务为例。更多有关任务的详细配置，请查看“章节三：任务详解”。 （ “GLUE模式(Java)”的执行代码托管到调度中心在线维护，相比“Bean模式任务”需要在执行器项目开发部署上线，更加简便轻量）<br>
前提：请确认“调度中心”和“执行器”项目已经成功部署并启动；<br>
步骤一：新建任务：<br>
登录调度中心，点击下图所示“新建任务”按钮，新建示例任务。然后，参考下面截图中任务的参数配置，点击保存。<br>
<img alt="553c2f130fbdde59e23d744f67c6708c_MD5.png" src="https://pages-9hu.pages.dev/attachments/553c2f130fbdde59e23d744f67c6708c_md5.png" target="_self"><br><img alt="fdf498cc4003625a57c740d3944c1397_MD5.png" src="https://pages-9hu.pages.dev/attachments/fdf498cc4003625a57c740d3944c1397_md5.png" target="_self"><br><br>请点击任务右侧 “GLUE” 按钮，进入 “GLUE编辑器开发界面” ，见下图。“GLUE模式(Java)” 运行模式的任务默认已经初始化了示例任务代码，即打印Hello World。 （ “GLUE模式(Java)” 运行模式的任务实际上是一段继承自IJobHandler的Java类代码，它在执行器项目中运行，可使用@Resource/@Autowire注入执行器里中的其他服务，详细介绍请查看第三章节）<br>
<img alt="6152dda2231ed3fbc198f78b09fd3c68_MD5.png" src="https://pages-9hu.pages.dev/attachments/6152dda2231ed3fbc198f78b09fd3c68_md5.png" target="_self"><br><img alt="f67554ea870aaee07a20984c31c7d61d_MD5.png" src="https://pages-9hu.pages.dev/attachments/f67554ea870aaee07a20984c31c7d61d_md5.png" target="_self"><br>步骤三：触发执行：<br>
请点击任务右侧 “执行” 按钮，可手动触发一次任务执行（通常情况下，通过配置Cron表达式进行任务调度出发）。<br>
步骤四：查看日志：<br>
请点击任务右侧 “日志” 按钮，可前往任务日志界面查看任务日志。 在任务日志界面中，可查看该任务的历史调度记录以及每一次调度的任务调度信息、执行参数和执行信息。运行中的任务点击右侧的“执行日志”按钮，可进入日志控制台查看实时执行日志。<br>
<img alt="c086f5dcc57fc27b21541eddf223349d_MD5.png" src="https://pages-9hu.pages.dev/attachments/c086f5dcc57fc27b21541eddf223349d_md5.png" target="_self"><br>在日志控制台，可以Rolling方式实时查看任务在执行器一侧运行输出的日志信息，实时监控任务进度；<br>
<img alt="c8d8dbdc504ef8a12c3bb2c367241561_MD5.png" src="https://pages-9hu.pages.dev/attachments/c8d8dbdc504ef8a12c3bb2c367241561_md5.png" target="_self"><br><br>配置属性详细说明：<br>
<br>执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 “执行器管理” 进行设置;
<br>描述：任务的描述信息，便于任务管理；
<br>路由策略：当执行器集群部署时，提供丰富的路由策略，包括；<br>
FIRST（第一个）：固定选择第一个执行器；<br>
LAST（最后一个）：固定选择最后一个执行器；<br>
ROUND（轮询）：；<br>
RANDOM（随机）：随机选择在线的执行器；<br>
CONSISTENT_HASH（一致性HASH）：分组下机器地址相同，不同JOB均匀散列在不同机器上，保证分组下机器分配JOB平均；且每个JOB固定调度其中一台机器；<br>
LEAST_FREQUENTLY_USED（最不经常使用）：单个JOB对应的每个执行器，使用频率最低的优先被选举；<br>
LEAST_RECENTLY_USED（最近最久未使用）：单个JOB对应的每个执行器，最久为使用的优先被选举；<br>
FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；<br>
BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；<br>
SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；
<br>Cron：触发任务执行的Cron表达式；
<br>运行模式：<br>
BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；<br>
GLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 “groovy” 源码方式维护，它在执行器项目中运行，可使用@Resource/@Autowire注入执行器里中的其他服务；<br>
GLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；<br>
GLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；<br>
GLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；
<br>JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHander”注解自定义的value值；
<br>子任务Key：每个任务都拥有一个唯一的任务Key(任务Key可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务Key所对应的任务的一次主动调度。
<br>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；<br>
单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；<br>
丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；<br>
覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；
<br>失败处理策略；调度失败时的处理策略；<br>
失败告警（默认）：调度失败时，将会触发失败报警，如发送报警邮件；<br>
失败重试：调度失败时，将会主动进行一次失败重试调度，重试调度后仍然失败将会触发一失败告警。注意当任务以failover方式路由时，每次失败重试将会触发新一轮路由。
<br>执行参数：任务执行所需的参数，多个参数时用逗号分隔，任务执行时将会把多个参数转换成数组传入；
<br>报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；
<br>负责人：任务的负责人；
<br><br>任务逻辑以JobHandler的形式存在于“执行器”所在项目中，开发流程如下：<br>
步骤一：执行器项目中，开发JobHandler：<br>`- 1、 新建一个继承com.xxl.job.core.handler.IJobHandler的Java类；
- 2、 该类被Spring容器扫描为Bean实例，如加“@Component”注解；
- 3、 添加 “@JobHander(value="自定义jobhandler名称")”注解，注解的value值为自定义的JobHandler名称，该名称对应的是调度中心新建任务的JobHandler属性的值。
（可参考Sample示例执行器中的DemoJobHandler，见下图）` 复制<br><img alt="3b7df640c59fc5f177ef883339770c2b_MD5.png" src="https://pages-9hu.pages.dev/attachments/3b7df640c59fc5f177ef883339770c2b_md5.png" target="_self"><br>步骤二：调度中心，新建调度任务<br>
参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “BEAN模式”，JobHandler属性填写任务注解@JobHander中定义的值；<br>
<img alt="51551f8976c3e258573a52c7df7778e1_MD5.png" src="https://pages-9hu.pages.dev/attachments/51551f8976c3e258573a52c7df7778e1_md5.png" target="_self"><br><br>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定JobHandler。开发流程如下：<br>
步骤一：调度中心，新建调度任务：<br>
参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “GLUE模式(Java)”；<br>
<img alt="fdf498cc4003625a57c740d3944c1397_MD5.png" src="https://pages-9hu.pages.dev/attachments/fdf498cc4003625a57c740d3944c1397_md5.png" target="_self"><br>步骤二：开发任务代码：<br>
选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发（也可以在IDE中开发完成后，复制粘贴到编辑中）。<br>
版本回溯功能（支持30个版本的版本回溯）：在GLUE任务的Web IDE界面，选择右上角下拉框“版本回溯”，会列出该GLUE的更新历史，选择相应版本即可显示该版本代码，保存后GLUE代码即回退到对应的历史版本；<br>
<img alt="f67554ea870aaee07a20984c31c7d61d_MD5.png" src="https://pages-9hu.pages.dev/attachments/f67554ea870aaee07a20984c31c7d61d_md5.png" target="_self"><br><br>步骤一：调度中心，新建调度任务<br>
参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “GLUE模式(Shell)”；<br>
步骤二：开发任务代码：<br>
选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发（也可以在IDE中开发完成后，复制粘贴到编辑中）。<br>
该模式的任务实际上是一段 “shell” 脚本；<br>
<img alt="fdf5d4d8a3c46b9490011795826db936_MD5.png" src="https://pages-9hu.pages.dev/attachments/fdf5d4d8a3c46b9490011795826db936_md5.png" target="_self"><br><br>步骤一：调度中心，新建调度任务<br>
参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “GLUE模式(Python)”；<br>
步骤二：开发任务代码：<br>
选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发（也可以在IDE中开发完成后，复制粘贴到编辑中）。<br>
该模式的任务实际上是一段 “python” 脚本；<br>
<img alt="3898bebc7aec00b0d9e0b6292f754316_MD5.png" src="https://pages-9hu.pages.dev/attachments/3898bebc7aec00b0d9e0b6292f754316_md5.png" target="_self"><br><br>步骤一：调度中心，新建调度任务<br>
参考上文“配置属性详细说明”对新建的任务进行参数配置，运行模式选中 “GLUE模式(NodeJS)”；<br>
步骤二：开发任务代码：<br>
选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发（也可以在IDE中开发完成后，复制粘贴到编辑中）。<br>
该模式的任务实际上是一段 “nodejS” 脚本；<br><br><br>点击进入"执行器管理"界面, 如下图:<br>
<img alt="48bc7daeef3855202933b02eb62a9f57_MD5.png" src="https://pages-9hu.pages.dev/attachments/48bc7daeef3855202933b02eb62a9f57_md5.png" target="_self"><br>1、"调度中心OnLine:"右侧显示在线的"调度中心"列表, 任务执行结束后, 将会以failover的模式进行回调调度中心通知执行结果, 避免回调的单点风险;<br>
2、“执行器列表” 中显示在线的执行器列表, 可通过"OnLine 机器"查看对应执行器的集群机器。<br>
点击按钮 “+新增执行器” 弹框如下图, 可新增执行器配置:<br>
<img alt="684e9dfd22dbeeadc9d0aae4f6c6e9a4_MD5.png" src="https://pages-9hu.pages.dev/attachments/684e9dfd22dbeeadc9d0aae4f6c6e9a4_md5.png" target="_self"><br>执行器属性说明<br>
AppName: 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用;<br>
名称: 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性;<br>
排序: 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表;<br>
注册方式：调度中心获取执行器地址的方式；<br>
自动注册：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址；<br>
手动录入：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用；<br>
机器地址："注册方式"为"手动录入"时有效，支持人工维护执行器的地址信息；<br><br>进入任务管理界面，点击“新增任务”按钮，在弹出的“新增任务”界面配置任务属性后保存即可。详情页参考章节 “三、任务详解”。<br><br>进入任务管理界面，选中指定任务。点击该任务右侧“编辑”按钮，在弹出的“编辑任务”界面更新任务属性后保存即可，可以修改设置的任务属性信息：<br><br>该操作仅针对GLUE任务。<br>
选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发。可参考章节 “3.2 GLUE模式(Java)”。<br><br>可对任务进行“暂停”和“恢复”操作。 需要注意的是，此处的暂停/恢复仅针对任务的后续调度触发行为，不会影响到已经触发的调度任务，如需终止已经触发的调度任务，可查看“4.8 终止运行中的任务”<br>
<img alt="a3c4b143ceecf3f029ce7d73c52e414a_MD5.png" src="https://pages-9hu.pages.dev/attachments/a3c4b143ceecf3f029ce7d73c52e414a_md5.png" target="_self"><br><br>点击“执行”按钮，可手动触发一次任务调度，不影响原有调度规则。<br>
<img alt="62749fdef7888584ae3154e65bf98a2d_MD5.png" src="https://pages-9hu.pages.dev/attachments/62749fdef7888584ae3154e65bf98a2d_md5.png" target="_self"><br><br>点击“日志”按钮，可以查看任务历史调度日志。在历史调入日志界面可查看每次任务调度的调度结果、执行结果等，点击“执行日志”按钮可查看执行器完整日志。<br>
<img alt="aa7c17cb421a9e2ae27edf644b60b4f5_MD5.png" src="https://pages-9hu.pages.dev/attachments/aa7c17cb421a9e2ae27edf644b60b4f5_md5.png" target="_self"><br><img alt="c086f5dcc57fc27b21541eddf223349d_MD5.png" src="https://pages-9hu.pages.dev/attachments/c086f5dcc57fc27b21541eddf223349d_md5.png" target="_self"><br>调度时间："调度中心"触发本次调度并向"执行器"发送任务执行信号的时间；<br>
调度结果："调度中心"触发本次调度的结果，200表示成功，500或其他表示失败；<br>
调度备注："调度中心"触发本次调度的日志信息；<br>
执行器地址：本次任务执行的机器地址<br>
运行模式：触发调度时任务的运行模式，运行模式可参考章节 “三、任务详解”；<br>
任务参数：本地任务执行的入参<br>
执行时间："执行器"中本次任务执行结束后回调的时间；<br>
执行结果："执行器"中本次任务执行的结果，200表示成功，500或其他表示失败；<br>
执行备注："执行器"中本次任务执行的日志信息；<br>
操作：<br>
"执行日志"按钮：点击可查看本地任务执行的详细日志信息；详见“4.7 查看执行日志”；<br>
"终止任务"按钮：点击可终止本地调度对应执行器上本任务的执行线程，包括未执行的阻塞任务一并被终止；<br><br><img alt="6e35e78902cc6e2232592f868e628434_MD5.png" src="https://pages-9hu.pages.dev/attachments/6e35e78902cc6e2232592f868e628434_md5.png" target="_self"><br>点击执行日志右侧的 “执行日志” 按钮，可跳转至执行日志界面，可以查看业务代码中打印的完整日志，如下图；<br><br>仅针对执行中的任务。 在任务日志界面，点击右侧的“终止任务”按钮，将会向本次任务对应的执行器发送任务终止请求，将会终止掉本次任务，同时会清空掉整个任务执行队列。<br>
<img alt="d00fb65c2dcb725e1ca36a57c57a434d_MD5.png" src="https://pages-9hu.pages.dev/attachments/d00fb65c2dcb725e1ca36a57c57a434d_md5.png" target="_self"><br>任务终止时通过 “interrupt” 执行线程的方式实现, 将会触发 “InterruptedException” 异常。因此如果JobHandler内部catch到了该异常并消化掉的话, 任务终止功能将不可用。<br>
因此, 如果遇到上述任务终止不可用的情况, 需要在JobHandler中应该针对 “InterruptedException” 异常进行特殊处理 (向上抛出) , 正确逻辑如下:<br>try{ // TODO
} catch (Exception e) { if (e instanceof InterruptedException) { throw e; } logger.warn("{}", e);
} 复制<br>而且，在JobHandler中开启子线程时，子线程也不可catch处理"InterruptedException"，应该主动向上抛出。<br><br>在任务日志界面，选中执行器和任务之后，点击右侧的"删除"按钮将会出现"日志清理"弹框，弹框中支持选择不同类型的日志清理策略，选中后点击"确定"按钮即可进行日志清理操<br>
<img alt="24e1b0c89fa6cd64cef71ff8da4b18e5_MD5.png" src="https://pages-9hu.pages.dev/attachments/24e1b0c89fa6cd64cef71ff8da4b18e5_md5.png" target="_self"><br><img alt="602f93fa5c4ef1a44ffdd09f16edef5d_MD5.png" src="https://pages-9hu.pages.dev/attachments/602f93fa5c4ef1a44ffdd09f16edef5d_md5.png" target="_self"><br><br>点击删除按钮，可以删除对应任务。<br>
<img alt="941f7c8670ab7f5567acfd887c0f576f_MD5.png" src="https://pages-9hu.pages.dev/attachments/941f7c8670ab7f5567acfd887c0f576f_md5.png" target="_self"><br><br><br>
<br>/doc :文档资料
<br>/db :“调度数据库”建表脚本
<br>/xxl-job-admin :调度中心，项目源码
<br>/xxl-job-core :公共Jar依赖
<br>/xxl-job-executor-samples :执行器，Sample示例项目（大家可以在该项目上进行开发，也可以将现有项目改造生成执行器项目）
<br><br>XXL-JOB调度模块基于Quartz集群实现，其“调度数据库”是在Quartz的11张集群mysql表基础上扩展而成。<br>
XXL-JOB首先定制了Quartz原生表结构前缀（XXL_JOBQRTZ）。<br>
<img alt="a21eac7915e3b1542a2a5e5981961a21_MD5.png" src="https://pages-9hu.pages.dev/attachments/a21eac7915e3b1542a2a5e5981961a21_md5.png" target="_self"><br>然后，在此基础上新增了几张张扩展表，如下：<br>
<br>XXL_JOB_QRTZ_TRIGGER_GROUP：执行器信息表，维护任务执行器信息；
<br>XXL_JOB_QRTZ_TRIGGER_REGISTRY：执行器注册表，维护在线的执行器和调度中心机器地址信息；
<br>XXL_JOB_QRTZ_TRIGGER_INFO：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；
<br>XXL_JOB_QRTZ_TRIGGER_LOG：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；
<br>XXL_JOB_QRTZ_TRIGGER_LOGGLUE：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；
<br>因此，XXL-JOB调度数据库共计用于16张数据库表。
<br><br>5.3.1 设计思想<br>
将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。<br>
将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。<br>
因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；<br>
5.3.2 系统组成<br>
调度模块（调度中心）： 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块； 支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。<br>
执行模块（执行器）： 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效； 接收“调度中心”的执行请求、终止请求和日志请求等。<br>
5.3.3 架构图<br>
<img alt="86f5b7bb21d36a1739af25d81fe5a4fa_MD5.png" src="https://pages-9hu.pages.dev/attachments/86f5b7bb21d36a1739af25d81fe5a4fa_md5.png" target="_self"><br><br>5.4.1 quartz的不足<br>
Quartz作为开源作业调度中的佼佼者，是作业调度的首选。但是集群环境中Quartz采用API的方式对任务进行管理，从而可以避免上述问题，但是同样存在以下问题：<br>
<br>问题一：调用API的的方式操作任务，不人性化；
<br>问题二：需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。
<br>问题三：调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；<br>
XXL-JOB弥补了quartz的上述不足之处。<br>
5.4.2 RemoteHttpJobBean<br>
常规Quartz的开发，任务逻辑一般维护在QuartzJobBean中，耦合很严重。XXL-JOB中“调度模块”和“任务模块”完全解耦，调度模块中的所有调度任务使用同一个QuartzJobBean，即RemoteHttpJobBean。不同的调度任务将各自参数维护在各自扩展表数据中，当触发RemoteHttpJobBean执行时，将会解析不同的任务参数发起远程调用，调用各自的远程执行器服务。<br>
这种调用模型类似RPC调用，RemoteHttpJobBean提供调用代理的功能，而执行器提供远程服务的功能。<br>
5.4.3 调度中心HA（集群）<br>
基于Quartz的集群方案，数据库选用Mysql；集群分布式并发环境中使用QUARTZ定时任务调度，会在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。
<br>`# for cluster
org.quartz.jobStore.tablePrefix = XXL_JOB_QRTZ_
org.quartz.scheduler.instanceId: AUTO
org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.isClustered: true
org.quartz.jobStore.clusterCheckinInterval: 1000` 复制<br>5.4.4 调度线程池<br>
默认线程池中线程的数量为10个，避免单线程因阻塞而引起任务调度延迟。<br>org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount: 10
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true 复制<br>XXL-JOB系统中业务逻辑在远程执行器执行，调度中心每次调度仅仅负责一次调度请求，执行器会将请求存入执行队列并且立即响应调度中心；相比直接在quartz的QuartzJobBean中执行业务逻辑，差别就像大象和羽毛；<br>
XXL-JOB调度中心中每个JOB逻辑非常 “轻”，单个JOB一次运行平均耗时基本在 “100ms” 之内（基本是网络开销）；因此，可以保证使用有限的线程支撑大量的JOB并发运行；上面配置的10个线程至少可以支撑100个JOB正常运行；<br>
5.4.5 @DisallowConcurrentExecution<br>
XXL-JOB调度模块的“调度中心”默认不使用该注解，即默认开启并行机制，因为RemoteHttpJobBean为公共QuartzJobBean，这样在多线程调度的情况下，调度模块被阻塞的几率很低，大大提高了调度系统的承载量。<br>
XXL-JOB的每个调度任务虽然在调度模块是并行调度执行的，但是任务调度传递到任务模块的“执行器”确实串行执行的，同时支持任务终止。<br>
5.4.6 misfire<br>
错过了触发时间，处理规则。 可能原因：服务重启；调度线程被QuartzJobBean阻塞，线程被耗尽；某个任务启用了@DisallowConcurrentExecution，上次调度持续阻塞，下次调度被错过；<br>
quartz.properties中关于misfire的阀值配置如下，单位毫秒：<br>
org.quartz.jobStore.misfireThreshold: 60000<br>
Misfire规则： withMisfireHandlingInstructionDoNothing：不触发立即执行，等待下次调度； withMisfireHandlingInstructionIgnoreMisfires：以错过的第一个频率时间立刻开始执行； withMisfireHandlingInstructionFireAndProceed：以当前时间为触发频率立刻触发一次执行；<br>
XXL-JOB默认misfire规则为：withMisfireHandlingInstructionDoNothing<br>CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(jobInfo.getJobCron()).withMisfireHandlingInstructionDoNothing();
CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(triggerKey).withSchedule(cronScheduleBuilder).build(); 复制<br>5.4.7 日志回调服务<br>
调度模块的“调度中心”作为Web服务部署时，一方面承担调度中心功能，另一方面也为执行器提供API服务。<br>
调度中心提供的"日志回调服务API服务"代码位置如下：<br>xxl-job-admin#com.xxl.job.admin.controller.JobApiController.callback 复制<br>“执行器”在接收到任务执行请求后，执行任务，在执行结束之后会将执行结果回调通知“调度中心”：<br>
5.4.8 任务HA（Failover）<br>
执行器如若集群部署，调度中心将会感知到在线的所有执行器，如“127.0.0.1:9997, 127.0.0.1:9998, 127.0.0.1:9999”。<br>
当任务"路由策略"选择"故障转移(FAILOVER)“时，当调度中心每次发起调度请求时，会按照顺序对执行器发出心跳检测请求，第一个检测为存活状态的执行器将会被选定并发送调度请<br>
<img alt="31f7d92729b4c698722d6d80f851c2d2_MD5.png" src="https://pages-9hu.pages.dev/attachments/31f7d92729b4c698722d6d80f851c2d2_md5.png" target="_self"><br>调度成功后，可在日志监控界面查看“调度备注”，如下；<br>
<img alt="07287211072bb81deb9ab376fa3719ee_MD5.png" src="https://pages-9hu.pages.dev/attachments/07287211072bb81deb9ab376fa3719ee_md5.png" target="_self"><br>“调度备注”可以看出本地调度运行轨迹，执行器的"注册方式”、“地址列表"和任务的"路由策略”。"故障转移(FAILOVER)"路由策略下，调度中心首先对第一个地址进行心跳检测，心跳失败因此自动跳过，第二个依然心跳检测失败…… 直至心跳检测第三个地址“127.0.0.1:9999”成功，选定为“目标执行器”；然后对“目标执行器”发送调度请求，调度流程结束，等待执行器回调执行结果。<br>
5.4.9 调度日志<br>
调度中心每次进行任务调度，都会记录一条任务日志，任务日志主要包括以下三部分内容：<br>
任务信息：包括“执行器地址”、“JobHandler”和“执行参数”等属性，根据这些参数，可以精确的定位任务执行的具体机器和任务代码；<br>
调度信息：包括“调度时间”、“调度结果”和“调度日志”等，根据这些参数，可以了解“调度中心”发起调度请求时具体情况。<br>
执行信息：包括“执行时间”、“执行结果”和“执行日志”等，根据这些参数，可以了解在“执行器”端任务执行的具体情况；<br>
<img alt="76cf302f348d3a3824a34f51d4d44da2_MD5.png" src="https://pages-9hu.pages.dev/attachments/76cf302f348d3a3824a34f51d4d44da2_md5.png" target="_self"><br>调度日志，针对单次调度，属性说明如下：<br>
执行器地址：任务执行的机器地址；<br>
JobHandler：Bean模式表示任务执行的JobHandler名称；<br>
任务参数：任务执行的入参；<br>
调度时间：调度中心，发起调度的时间；<br>
调度结果：调度中心，发起调度的结果，SUCCESS或FAIL；<br>
调度备注：调度中心，发起调度的备注信息，如地址心跳检测日志等；<br>
执行时间：执行器，任务执行结束后回调的时间；<br>
执行结果：执行器，任务执行的结果，SUCCESS或FAIL；<br>
执行备注：执行器，任务执行的备注信息，如异常日志等；<br>
执行日志：任务执行过程中，业务代码中打印的完整执行日志，见“4.7 查看执行日志”；<br>
5.4.10 任务依赖<br>
原理：XXL-JOB中每个任务都对应有一个任务Key，同时，每个任务支持设置属性“子任务Key”，因此，通过“任务Key”可以匹配任务依赖关系。<br>
当父任务执行结束并且执行成功时，将会根据“子任务Key”匹配子任务依赖，如果匹配到子任务，将会主动触发一次子任务的执行。<br>
在任务日志界面，点击任务的“执行备注”的“查看”按钮，可以看到匹配子任务以及触发子任务执行的日志信息，如无信息则表示未触发子任务执行，可参考下图。<br>
<img alt="a55021810a5a2ff13b70d00d68561d9c_MD5.png" src="https://pages-9hu.pages.dev/attachments/a55021810a5a2ff13b70d00d68561d9c_md5.png" target="_self"><br><img alt="67c8ad806b5dbca070edfb81cfe11ab1_MD5.png" src="https://pages-9hu.pages.dev/attachments/67c8ad806b5dbca070edfb81cfe11ab1_md5.png" target="_self"><br><br>5.5.1 “Bean模式” 任务<br>
开发步骤：可参考 “章节三” ； 原理：每个Bean模式任务都是一个Spring的Bean类实例，它被维护在“执行器”项目的Spring容器中。任务类需要加“@JobHander(value=“名称”)”注解，因为“执行器”会根据该注解识别Spring容器中的任务。任务类需要继承统一接口“IJobHandler”，任务逻辑在execute方法中开发，因为“执行器”在接收到调度中心的调度请求时，将会调用“IJobHandler”的execute方法，执行任务逻辑。<br>
5.5.2 “GLUE模式(Java)” 任务<br>
开发步骤：可参考 “章节三” ； 原理：每个 “GLUE模式(Java)” 任务的代码，实际上是“一个继承自“IJobHandler”的实现类的类代码”，“执行器”接收到“调度中心”的调度请求时，会通过Groovy类加载器加载此代码，实例化成Java对象，同时注入此代码中声明的Spring服务（请确保Glue代码中的服务和类引用在“执行器”项目中存在），然后调用该对象的execute方法，执行任务逻辑。<br>
5.5.3 GLUE模式(Shell) + GLUE模式(Python) + GLUE模式(NodeJS)<br>
开发步骤：可参考 “章节三” ； 原理：脚本任务的源码托管在调度中心，脚本逻辑在执行器运行。当触发脚本任务时，执行器会加载脚本源码在执行器机器上生成一份脚本文件，然后通过Java代码调用该脚本；并且实时将脚本输出日志写到任务日志文件中，从而在调度中心可以实时监控脚本运行情况；脚本返回码为0时表示执行成功，其他标示执行失败。<br>
目前支持的脚本类型如下：<br>
<br>shell脚本：任务运行模式选择为 "GLUE模式(Shell)"时支持 “shell” 脚本任务；
<br>python脚本：任务运行模式选择为 "GLUE模式(Python)"时支持 “python” 脚本任务；
<br>nodejs脚本：务运行模式选择为 "GLUE模式(NodeJS)"时支持 “nodejs” 脚本任务；<br>
5.5.4 执行器<br>
执行器实际上是一个内嵌的Jetty服务器，默认端口9999，如下图配置文件所示（参数：xxl.job.executor.port）。<br>
<img alt="a979f07bbcdd4bd7a95c5aae56fe0d27_MD5.png" src="https://pages-9hu.pages.dev/attachments/a979f07bbcdd4bd7a95c5aae56fe0d27_md5.png" target="_self">
在项目启动时，执行器会通过“@JobHander”识别Spring容器中“Bean模式任务”，以注解的value属性为key管理起来。<br>
“执行器”接收到“调度中心”的调度请求时，如果任务类型为“Bean模式”，将会匹配Spring容器中的“Bean模式任务”，然后调用其execute方法，执行任务逻辑。如果任务类型为“GLUE模式”，将会加载GLue代码，实例化Java对象，注入依赖的Spring服务（注意：Glue代码中注入的Spring服务，必须存在与该“执行器”项目的Spring容器中），然后调用execute方法，执行任务逻辑。<br>
5.5.5 任务日志<br>
XXL-JOB会为每次调度请求生成一个单独的日志文件，需要通过 “XxlJobLogger.log” 打印执行日志，“调度中心”查看执行日志时将会加载对应的日志文件。<br>
(历史版本通过重写LOG4J的Appender实现，存在依赖限制，该方式在新版本已经被抛弃)<br>
日志文件存放的位置可在“执行器”配置文件进行自定义，默认目录格式为：/data/applogs/xxl-job/jobhandler/“格式化日期”/“数据库调度日志记录的主键ID.log”。<br>
在JobHandler中开启子线程时，子线程将会将会把日志打印在父线程即JobHandler的执行日志中，方便日志追踪。
<br><br>5.6.1 一次完整的任务调度通讯流程<br>
<br>1、“调度中心”向“执行器”发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌jetty服务器，默认端口9999;
<br>2、“执行器”执行任务逻辑；
<br>3、“执行器”http回调“调度中心”调度结果: “调度中心”中接收回调的服务，是针对执行器开放一套API服务;<br>
5.6.2 通讯数据加密<br>
调度中心向执行器发送的调度请求时使用RequestModel和ResponseModel两个对象封装调度请求参数和响应数据, 在进行通讯之前底层会将上述两个对象对象序列化，并进行数据协议以及时间戳检验,从而达到数据加密的功能;
<br><br>自v1.5版本之后, 任务取消了"任务执行机器"属性, 改为通过任务注册和自动发现的方式, 动态获取远程执行器地址并执行。<br>
AppName: 每个执行器机器集群的唯一标示, 任务注册以 “执行器” 为最小粒度进行注册; 每个任务通过其绑定的执行器可感知对应的执行器机器列表;<br>
注册表: 见"XXL_JOB_QRTZ_TRIGGER_REGISTRY"表, “执行器” 在进行任务注册时将会周期性维护一条注册记录，即机器地址和AppName的绑定关系; “调度中心” 从而可以动态感知每个AppName在线的机器列表;<br>
执行器注册: 任务注册Beat周期默认30s; 执行器以一倍Beat进行执行器注册, 调度中心以一倍Beat进行动态任务发现; 注册信息的失效时间被三倍Beat;<br>
执行器注册摘除：执行器销毁时，将会主动上报调度中心并摘除对应的执行器机器信息，提高心跳注册的实时性；<br>
为保证系统"轻量级"并且降低学习部署成本，没有采用Zookeeper作为注册中心，采用DB方式进行任务注册发现；<br><br>自v1.6.2之后，任务执行结果通过 “IJobHandler” 的返回值 “ReturnT” 进行判断； 当返回值符合 “ReturnT.code == ReturnT.SUCCESS_CODE” 时表示任务执行成功，否则表示任务执行失败，而且可以通过 “ReturnT.msg” 回调错误信息给调度中心； 从而，在任务逻辑中可以方便的控制任务执行结果；<br><br>执行器集群部署时，任务路由策略选择"分片广播"情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；<br>
“分片广播” 以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。<br>
“分片广播” 和普通任务开发流程一致，不同之处在于可以可以获取分片参数，获取分片参数对象的代码如下（可参考Sample示例执行器中的示例任务"ShardingJobHandler" ）：<br>
ShardingUtil.ShardingVO shardingVO = ShardingUtil.getShardingVo();<br>
该分片参数对象拥有两个属性：<br>
index：当前分片序号(从0开始)，执行器集群列表中当前执行器的序号；<br>
total：总分片数，执行器集群的总机器数量；<br>
该特性适用场景如：<br>
1、分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；<br>
2、广播任务场景：广播执行器机器运行shell脚本、广播集群节点进行缓存更新等<br><br>为提升系统安全性，调度中心和执行器进行安全性校验，双方AccessToken匹配才允许通讯；<br>
调度中心和执行器，可通过配置项 “xxl.job.accessToken” 进行AccessToken的设置。<br>
调度中心和执行器，如果需要正常通讯，只有两种设置；<br>
设置一：调度中心和执行器，均不设置AccessToken；关闭安全性校验；<br>
设置二：调度中心和执行器，设置了相同的AccessToken；<br><br>调度中心提供了API服务，供执行器和业务方选择使用，目前提供的API服务有：<br>
1、任务结果回调服务；<br>
2、执行器注册服务；<br>
3、执行器注册摘除服务；<br>
4、触发任务单次执行服务，支持任务根据业务事件触发；<br>
调度中心API服务位置：com.xxl.job.core.biz.AdminBiz.java<br>
调度中心API服务请求参考代码：com.xxl.job.dao.impl.AdminBizTest.java]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/分布式事务架构/xxl-job轻量级分布式任务调度框架文档.html</link><guid isPermaLink="false">知识库/工作技能/分布式/分布式事务架构/XXL-JOB轻量级分布式任务调度框架文档.md</guid><pubDate>Mon, 15 Jul 2024 15:11:40 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/63ef3ef2cea1ad8667df2b885a676c6f_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/63ef3ef2cea1ad8667df2b885a676c6f_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[分布式事务处理【TX-LCN】]]></title><description><![CDATA[<br><br>主要内容<br>
<br>分布式事务
<br>分布式事务理论依据
<br>TX-LCN 概述
<br>TX-LCN 事务模式
<br>XA 的两阶段提交方案
<br>TxManager 搭建
<br>基于 Spring Cloud 的 TX-LCN
<br><br><br>在<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020" target="_self">分布式系统</a>中，事务参与者在不同的分布式节点上或事务操作的数据源不是同一个，这些情况产生的事务都叫做分布式事务。<br>例如：<br>
项目 A 实现 Tb_item 表新增、项目 B 实现tb_item_param 新增，现在需要实现商品新增，需要把项目 A 和项目 B 两个项目新增的方法组成一个事务，这个事务就是分布式事务。<br>例如：项目中向 MySQL 做添加，同时还需要向 Redis 或 MongoDB 添加，希望在出现异常情况时执行 MySQL 或 Redis 或 MongoDB，这种情况也应用的情况。<br><br>事务的概念最早是在学习数据库（MySQL、Oracle）中接触到的，一个事务（本地事务）就是一系列 SQL 语句的集合，只要在执行过程中一条 SQL 出错就会导致整个事务失败，回滚到原点。而在分布式系统中存在多模块完成一次业务。那么就存在一个业务由多模块操作同一个数据源。<br>
<img alt="e20b04926c2ed678323ee8a91bad5f77_MD5.png" src="https://pages-9hu.pages.dev/attachments/e20b04926c2ed678323ee8a91bad5f77_md5.png" target="_self"><br>甚至可能存在一个业务横跨多种数据源节点的可能。这些问题都可以由分布式事务解决方案 TX-LCN 解决。<br>
<img alt="4146abdd7b7cf46b4b226011c8c86be6_MD5.png" src="https://pages-9hu.pages.dev/attachments/4146abdd7b7cf46b4b226011c8c86be6_md5.png" target="_self"><br><br><br>分布式事务通常采用 2PC 协议，全称 Two Phase Commitment Protocol。该协议主要为了解决在分布式数据库场景下，所有节点间数据一致性的问题。分布式事务通过 2PC 协议将提交分成两个阶段：<br>
<br>prepare
<br>commit/rollback
<br>阶段一为准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者 ready 时，向 transaction manager 报告已准备就绪。<br>阶段二为提交阶段（commit）。当 transaction manager 确认所有参与者都 ready 后，向所有参与者发送 commit 命令。<br><br>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功并且对外发消息成功，要么两者都失败。<br>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。不控制就是不引入分布式事务，部分控制就是各 种变种的两阶段提交，包括上面提到的 消息事务+最终一致性、TCC 模式，而完全控制就是完全实现两阶段提交。部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<br><br>分布式事务存在两大理论依据：CAP 定理和 BASE 理论。<br><br>CAP 定理是指在一个分布式系统中Consistency(一致性)、Availability(可用性)、Partitiontolerance(分区容错性)，最多同时满足其中两个，三者不可兼得。<br><br>在分布式系统中所有节点的状态是一样的。<br><br>在集群中一部分节点出现故障后，整个集群是否还能响应客户端请求。<br><br>以实际效果而言，分区相当于对操作的时限要求。如果系统不能在一定时限内达到数据一致性，就意味着发生了分区的情况，此时就必须在 A 和 C 中做选择。<br><br>是指 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。<br>
BASE 理论是对 CAP 中一致性和可用性权衡的结果，是基于 CAP 演化而来的。<br>BASE 理论核心思想：即使无法做到强一致性，每个应用都可以根据自身业务特点，采用适当的方式达到最终一致性。<br><br>是指在分布式系统中出现不可知故障的时候，允许损失部分可用性。此处要注意：损失部分可用性，不代表整个系统不可用。<br>
例如：<br>
<br>可以增加响应时间。由之前 0.5 秒，在出现故障的时候变成 1~2 秒。
<br>由于一些特殊原因，使网站访问流量激增，为了保证整个系统的稳定性，部分访问者可能被引导到降级页面中。
<br><br>是指系统中数据允许存在中间状态（软状态），并认为这个状态是不影响系统的可用性的。通俗解释：允许分布式节点之间存在同步延迟。<br>
例如：<br>
在 Eureka 集群中数据同步时就存在软状态。<br><br>允许整个系统中数据在经过一定时间后，最终能达到整个系统的一致性。但是这个时间绝对不可以过长。<br>强一致性要求系统接收请求后，整个系统必须达到一致性效果，才会响应结果。<br>最终一致性是弱一致性的特例。满足最终一致性的系统在响应给用户结果时整个系统可能是没有达到一致性的，但是最终一定会达到一致性效果的。<br><br><br>LCN 框架在 2017 年 6 月发布第一个版本，目前最新已经达到 5.0 版本。<br>
LCN 早期设计时，1.0 版本和 2.0 版本设计步骤如下：<br>
1）锁定事务单元（Lock）<br>
2）确认事务模块状态（Confirm）<br>
3）通知事务（<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=Notify&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=Notify&amp;spm=1001.2101.3001.7020" target="_self">Notify</a>）<br>取各自首字母后名称为 LCN。<br>
LCN 框架从 5.0 开始兼容了 LCN、TCC、TXC 三种事务模式，为了和 LCN 框架区分，从5.0 开始把 LCN 框架更名为：TX-LCN 分布式事务框架。<br><br>TX-LCN 由两大模块组成，TxClient、TxManager。<br>
TxClient 作为模块的依赖框架，提供了 TX-LCN 的标准支持，事务发起方和参与方都属于TxClient。TxManager 作为分布式事务的控制方，控制整个事务。<br>
<img alt="7e0a3ef593bc3a8b3911aa1385b1120b_MD5.png" src="https://pages-9hu.pages.dev/attachments/7e0a3ef593bc3a8b3911aa1385b1120b_md5.png" target="_self"><br><br><br>是指在事务发起方开始执行业务代码之前先调用 TxManager 创建事务组对象，然后拿到事务标识 GroupId 的过程。<br><br>添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息通知给 TxManager 的操作。<br><br>是 指 在 发 起 方 执 行 完 业 务 代 码 以 后 ， 将 发 起 方 执 行 结 果 状 态 通 知 给TxManager,TxManager 将根据事务最终状态和事务组的信息来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方。<br><br>Tx-LCN 5.0 开始支持三种事务模式，分别是：LCN、TCC、TXC 模式。<br>
每种模式在实际使用时有着自己对应的注解。<br>`LCN：@LcnTransaction
TCC：@TccTransaction
TXC：@TxcTransaction` 复制<br><br><br>LCN 模式是通过代理 JDBC 中 Connection 的方式实现对本地事务的操作，然后在由TxManager 统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由 LCN 连接池管理。<br><br>
<br>该模式对代码的嵌入性低。
<br>该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块。
<br>该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。
<br>该模式缺陷在于代理的连接需要随事务发起方一同释放连接，增加了连接占用的时间。
<br>总结：LCN 模式适合能用 JDBC 连接的所有支持事务的数据库。 <br><br><br>TCC 事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对 XA 的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。主要由三步操作，Try: 尝试执行业务、 Confirm:确认执行业务、 Cancel: 取消执行业务。<br><br>每个 TCC 事务处理方法可以额外包含 confirmXxx 和 cancelXxx 的方法（），出现失败问题，需要在 cancel 中通过业务逻辑把改变的数据还原回来。<br>`confirmXxx 和 cancelXxx 两个方法会由 TxManager 进行统一协调调用。
confirmXxx 和 cancelXxx 也可以在@TccTransaction 注解中通过属性明确指定。` 复制<br>`@TccTransaction
public String demo(){ // 正常的 service 方法，也是 Try 尝试执行执行
}
public void confirmDemo(){ // 当 demo 方法没有出现异常时执行的方法 // 方法名称必须叫做 confirm+代理方法首字母
}
public void cancelDemo(){ // 当 demo 方法出现异常时执行的方法 // 方法名称必须叫做 cancel+代理方法首字母
}` 复制<br><br>
<br>该模式对代码的嵌入性高，要求每个业务需要写二个以上步骤的操作。
<br>该模式对有无本地事务控制都可以支持，使用面更广。
<br>数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。
<br>总结：Tcc 模式应用于所有不支持 XA 事务的软件。例如：redis，mongodb 等。<br><br><br>TXC 模式命名来源于淘宝，实现原理是在执行 SQL 之前，先查询 SQL 的影响数据，然后保存执行的 SQL 信息和创建锁。当需要回滚的时候就采用这些记录数据回滚数据库，目前锁实现依赖 redis 分布式锁控制。（在使用 lcn 时必须要配置 redis 参数）<br><br>
<br>该模式同样对代码的嵌入性低。
<br>该模式仅限于对支持 SQL 方式的模块支持。
<br>该模式由于每次执行 SQL 之前需要先查询影响数据，因此相比 LCN 模式消耗资源与时间要多。
<br>该模式不会占用数据库的连接资源。
<br>总结：只能用在支持 SQL 的数据库。对资源消耗较多。建议使用 LCN 模式<br><br><br>XA 协议由 Oracle Tuxedo 首先提出的，并交给 X/Open 组织，作为资源管理器（数据库）与事务管理器的接口标准。目前，Oracle、Informix、DB2 和 Sybase 等各大数据库厂家都提供对 XA 的支持。XA 协议采用两阶段提交方式来管理分布式事务。XA 接口提供资源管理器与事务管理器之间进行通信的标准接口。<br>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。XA 接口函数由数据库厂商提供。<br>X/Open 组织（即现在的 Open Group）定义了分布式事务处理模型。X/Open DTP 模型（1994）包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）、通信资源管理器（CRM）四部分。一般，常见的事务管理器（TM）是交易中间件，常见的资源管理器（RM）是数据库，常见的通信资源管理器（CRM）是消息中间件。<br><br><img alt="7b8256e7459f68f4e73c9b29c0d49ee4_MD5.png" src="https://pages-9hu.pages.dev/attachments/7b8256e7459f68f4e73c9b29c0d49ee4_md5.png" target="_self"><br>如果在程序中开启了事务，那么在应用程序发出提交/回滚请求后，数据库执行操作，而后将成功/失败返回给应用程序，程序继续执行。<br>一阶段提交协议相对简单。优点也很直观，它不用再与其他的对象交互，节省了判断步骤和时间，所以在性能上是在阶段提交协议中最好的。但缺点也很明显：数据库确认执行事务的时间较长，出问题的可能性就随之增大。如果有多个数据源，一阶段提交协议无法协调他们之间的关系。<br><br>在一阶段协议的基础上，有了二阶段协议，二阶段协议的好处是添加了一个管理者角色。<br>
<img alt="8cb99c4b7fad10f77566f525f8dcbbc1_MD5.png" src="https://pages-9hu.pages.dev/attachments/8cb99c4b7fad10f77566f525f8dcbbc1_md5.png" target="_self"><br>很明显，二阶段协议通过将两层变为三层，增加了中间的管理者角色，从而协调多个数据源之间的关系，二阶段提交协议分为两个阶段。<br>
<img alt="bd2a0e6994a242c11f23cb056963ef3d_MD5.png" src="https://pages-9hu.pages.dev/attachments/bd2a0e6994a242c11f23cb056963ef3d_md5.png" target="_self"><br>应用程序调用了事务管理器的提交方法，此后第一阶段分为两个步骤：<br>
事务管理器通知参与该事务的各个资源管理器，通知他们开始准备事务。<br>
资源管理器接收到消息后开始准备阶段，写好事务日志并执行事务，但不提交，然后将是否就绪的消息返回给事务管理器（此时已经将事务的大部分事情做完，以后的内容耗时极小）。<br>
<img alt="1cfd2d384fedcde751a08d3c00b35a09_MD5.png" src="https://pages-9hu.pages.dev/attachments/1cfd2d384fedcde751a08d3c00b35a09_md5.png" target="_self"><br>第二阶段也分为两个步骤：<br>
事务管理器在接受各个消息后，开始分析，如果有任意其一失败，则发送回滚命令，否则发送提交命令。<br>
各个资源管理器接收到命令后，执行（耗时很少），并将提交消息返回给事务管理器。<br>
事务管理器接受消息后，事务结束，应用程序继续执行。<br>
为什么要分两步执行？一是因为分两步，就有了事务管理器统一管理的机会；二尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作，这样，最后的提交阶段将是耗时极短，耗时极短意味着操作失败的可能性也就降低。<br>同时，二阶段提交协议为了保证事务的一致性，不管是事务管理器还是各个资源管理器，每执行一步操作，都会记录日志，为出现故障后的恢复准备依据。<br>
缺点：<br>
1 二阶段提交协议的存在的弊端是阻塞，因为事务管理器要收集各个资源管理器的响应消息，如果其中一个或多个一直不返回消息，则事务管理器一直等待，应用程序也被阻塞，甚至可能永久阻塞。<br>2 两阶段提交理论的一个广泛工业应用是 XA 协议。目前几乎所有收费的商业数据库都支持 XA 协议。XA 协议已在业界成熟运行数十年，但目前它在互联网海量流量的应用场景中，吞吐量这个瓶颈变得十分致命，因此很少被用到。<br><br><br>新建项目 TxManager，并添加依赖。<br>
依赖包含了 Spring-boot 的依赖，版本是 2.0.5，如果希望把版本改变成 2.2.2 或其他版本只需要添加 spring-boot-starter-parent 继承即可<br>`&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.codingapi.txlcn&lt;/groupId&gt; &lt;artifactId&gt;txlcn-tm&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;
&lt;/dependencies&gt;` 复制<br><br>执行 tx-manager.sql 文件（在任意的数据库下执行即可）。<br>tx-manager.sql<br>``/* Navicat Premium Data Transfer Source Server : local Source Server Type : MySQL Source Server Version : 100309 Source Host : localhost:3306 Source Schema : tx-manager Target Server Type : MySQL Target Server Version : 100309 File Encoding : 65001 Date: 29/12/2018 18:35:59
*/
CREATE DATABASE IF NOT EXISTS `tx-manager` DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
USE `tx-manager`; SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0; -- ----------------------------
-- Table structure for t_tx_exception
-- ----------------------------
DROP TABLE IF EXISTS `t_tx_exception`;
CREATE TABLE `t_tx_exception` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `group_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `unit_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `mod_id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `transaction_state` tinyint(4) NULL DEFAULT NULL, `registrar` tinyint(4) NULL DEFAULT NULL, `ex_state` tinyint(4) NULL DEFAULT NULL COMMENT '0 待处理 1已处理', `remark` varchar(10240) NULL DEFAULT NULL COMMENT '备注', `create_time` datetime(0) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 967 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic; SET FOREIGN_KEY_CHECKS = 1;`` 复制<br>在 MySQL 生成 tx-manager 的数据库，在数据库中新建 t_tx_exception 的表，此表用作存储事务组信息。<br>
注意：<br>
默认情况下 tx-manager 需要记录日志信息的，需要在项目中配置日志连接数据库相关参数，其中日志存储数据库没有要求，可以存储到任意数据库中，当运行后会自动在数据库中生成一个日志表。如果不希望记录日志可以直接设置 tx-lcn.logger.enabled=false，关闭日志功能，下面的日志连接数据库参数也可以不用配置。<br>
在实际案例演示中会把所有的日志记录功能关闭。如果希望记录记录日志需要把下面代码在所有引用 tx-lcn 的项目的配置文件中进行配置。<br>`tx-lcn.logger.enabled=true
tx-lcn.logger.driver-class-name=com.mysql.jdbc.Driver
tx-lcn.logger.jdbc-url=jdbc:mysql://192.168.8.131:3306/tx-mana
ger?characterEncoding=UTF-8
tx-lcn.logger.username=root
tx-lcn.logger.password=root` 复制<br><br>在 TxManager 项目的 resource 下新建 application.properties。tx-lcn 在当前版本有个 bug<br>
只能使用 properties 文件，使用 yml 文件会导致配置文件无法被加载的问题。<br>
配置文件中内容上半部分是 tx-manager 数据库的连接信息。中间包含 redis 连接信息（此处连接的是 redis 单机版，端口默认，没有密码），下面是关闭日志记录功能<br>
小提示：<br>
依赖 Redis，所以需要安装 Redis。<br>
7970 是客户端访问端口，是 Txmanager 可视化界面访问端口，此端口任意。<br>
更加详细配置信息可以看 txlcn-tm-5.0.2.RELEASE.zip 中 application.propertie<br>`# TM事务管理器的服务端WEB访问端口。提供一个可视化的界面。端口自定义。
server.port=7970 # TM事务管理器，需要访问数据库，实现分布式事务状态记录。
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/tx-manager?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=root # TM事务管理器，是依赖Redis使用分布式事务协调的。尤其是TCC和TXC两种事务模型。
spring.redis.host=192.168.89.141
spring.redis.port=6379
spring.redis.database=0 # 为spring应用起名。
spring.application.name=tx-lcn-transaction-manager # TM事务管理器，提供的WEB管理平台的登录密码。无用户名。 默认是codingapi
tx-lcn.manager.admin-key=bjsxt
# 日志。如果需要TM记录日志。则开启，赋值为true，并提供后续的配置。
tx-lcn.logger.enabled=false # 为日志功能，提供数据库连接。和之前配置的分布式事务管理依赖使用的数据源不同。
# tx-lcn.logger.driver-class-name=com.mysql.cj.jdbc.Driver
# tx-lcn.logger.jdbc-url=jdbc:mysql://localhost:3306/tx-manager?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8
# tx-lcn.logger.username=root
# tx-lcn.logger.password=root` 复制<br><br>注意注解@EnableTrasactionManagerServer 必须有。<br>`/** * EnableTransactionManagerServer - 开启事务管理器服务端。（事务协调器） */
@SpringBootApplication
@EnableTransactionManagerServer
public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class,args); }
}` 复制<br><br>在浏览器输入：http://localhost:7970 访问。<br>
密码默认是 codingapi<br>
可以在配置文件中修改登录密码<br>`tx-lcn.manager.admin-key=bjsxt` 复制<br><img alt="65dc0a9079e0ac68f5fdc862a5bdfc61_MD5.png" src="https://pages-9hu.pages.dev/attachments/65dc0a9079e0ac68f5fdc862a5bdfc61_md5.png" target="_self"><br><br><br>注意：不要给 student 表添加外键约束。如果添加会导致分布式事务执行时 student 新增失败，因为 teacher 没有提交时 student 的 tid 值无法获取。<br>
<img alt="f84ee5944e184fd8b04ad28d41db3481_MD5.png" src="https://pages-9hu.pages.dev/attachments/f84ee5944e184fd8b04ad28d41db3481_md5.png" target="_self"><br><br>案例使用聚合项目进行演示。<br>
创建父项目，名称为 LcnParent<br><br>txlcn-tc 是 TX-LCN 的客户端包<br>
txlcn-txmsg-netty 是 LCN 客户端连接 TxManager 需要的包<br>`&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.codingapi.txlcn&lt;/groupId&gt; &lt;artifactId&gt;txlcn-tc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.codingapi.txlcn&lt;/groupId&gt; &lt;artifactId&gt;txlcn-txmsg-netty&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;` 复制<br><br>把实体类提出了<br>
新建两个实体类。<br>
新建 com.bjsxt.pojo.Teacher<br>`@Data
public class Teacher { private Long id; private String name;
}` 复制<br>新建 com.bjsxt.pojo.Student<br>`@Data
public class Student { private Long id; private String name; private Long tid;
}` 复制<br><br>新建 teacher_insert 项目<br><br>依赖 pojo<br>`&lt;dependencies&gt; &lt;dependency&gt; &lt;artifactId&gt;pojo&lt;/artifactId&gt; &lt;groupId&gt;com.bjsxt&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;
&lt;/dependencies&gt;` 复制<br><br>新建 application.yml. 数据源连接的是 Teacher 表所在数据库 eureka 单机版可以省略。<br>
manager-address 配置 TxManager 项目的 ip 及端口。端口是内部访问端口，而不是可视化页面的端口。<br>`spring: datasource: url: jdbc:mysql://localhost:3306/microservice driver-class-name: com.mysql.jdbc.Driver username: root password: root application: name: teacher-insert
server: port: 8080
eureka: client: service-url: defaultZone: http://localhost:8761/eureka/
tx-lcn: client: manager-address: 127.0.0.1:8070` 复制<br><br>新建 com.bjsxt.mapper.TeacherMapper<br>`@Mapper
public interface TeacherMapper { @Insert("insert into teacher values(#{id},#{name})") int insert(Teacher teacher);
}` 复制<br><br>新建 com.bjsxt.service.TeacherService 及实现类。方法上@Transactional 一定要有。本地事务控制。<br>
@LcnTransaction 表示当前方法加入到分布式事务控制。<br>
@LcnTransaction 属性 propagation 可取值DTXPropagation.REQUIRED：默认值，表示如果当前没有事务组创建事务组，如果有事务组，加入事务组。多用在事务发起方。<br>
DTXPropagation.SUPPORTS：如果当前没有事务组以本地事务运行，如果当前有事务组加入事务组。多用在事务参与方法。<br>`public interface TeacherService { int insert(Teacher teacher);
}` 复制<br>`@Service
public class TeacherServiceImpl implements TeacherService { @Autowired private TeacherMapper teacherMapper; @Override @LcnTransaction @Transactional public int insert(Teacher teacher) { return teacherMapper.insert(teacher); }
}` 复制<br><br>新建 com.bjsxt.controller.TeacherController。<br>
由于在 student_insert 中通过 OpenFeign 进行条件，参数使用请求体数据，所以控制器方法的参数需要添加@RequestBody<br>`@Controller
public class TeacherController { @Autowired private TeacherService teacherService; @RequestMapping("/insert") @ResponseBody public int insert(@RequestBody Teacher teacher){ System.out.println("taecher"+teacher); return teacherService.insert(teacher); }
}` 复制<br><br>新建 com.bjsxt.TeacherInsertApplication。<br>
一定要有注解@EnableDistributedTransaction 表示启动分布式事务<br>`@SpringBootApplication
@EnableDistributedTransaction
public class TeacherInsertApplication { public static void main(String[] args){ SpringApplication.run(TeacherInsertApplication.class,args); }
}` 复制<br><br><br>添加对 pojo 依赖<br>`&lt;dependencies&gt; &lt;dependency&gt; &lt;artifactId&gt;pojo&lt;/artifactId&gt; &lt;groupId&gt;com.bjsxt&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;
&lt;/dependencies&gt;` 复制<br><br>新建 application.yml<br>`spring: datasource: url: jdbc:mysql://localhost:3306/microservice driver-class-name: com.mysql.jdbc.Driver username: root password: root application: name: student-insert
server: port: 8081
eureka: client: service-url: defaultZone: http://localhost:8761/eureka/
tx-lcn: client: manager-address: 127.0.0.1:807` 复制<br><br>新建 com.bjsxt.feign.TeacherInsertFeign<br>`@FeignClient("teacher-insert")
public interface TeacherInsertFeign { @RequestMapping("/insert") int insert(Teacher teacher);
}` 复制<br><br>新建 com.bjsxt.mapper.StudentMapper<br>`@Mapper
public interface StudentMapper { @Insert("insert into student values(#{id},#{name},#{tid})") int insert(Student student);
}` 复制<br><br>新建 com.bjsxt.service.StudentService。<br>
实现类中对 Teacher 和 Student 的主键都是随机数，为了测试时多次测试方便，所以没有给固定值。Student 的姓名通过客户端请求参数传递的，其他都不需要通过参数设置。<br>`public interface StudentService { int insert(Student student);
}` 复制<br>`@Service
public class StudentServiceImpl implements StudentService { @Autowired private StudentMapper studentMapper; @Autowired private TeacherInsertFeign teacherInsertFeign; @Override @LcnTransaction @Transactional public int insert(Student student) { Teacher teacher = new Teacher(); Random random = new Random(); teacher.setId((long)random.nextInt(10000)); teacher.setName("随意的名称"); student.setTid(teacher.getId()); student.setId((long)random.nextInt(10000)); teacherInsertFeign.insert(teacher); return studentMapper.insert(student); }
}` 复制<br><br>新建 com.bjsxt.controller.StudentController<br>`@Controller
public class StudentController { @Autowired private StudentService studentService; @RequestMapping("/insert") @ResponseBody public int insert(Student student){ return studentService.insert(student); }
}` 复制<br><br>新建 com.bjsxt.StudentInsertApplication<br>`@SpringBootApplication
@EnableDistributedTransaction
@EnableFeignClients
public class StudentInsertApplication { public static void main(String[] args) { SpringApplication.run(StudentInsertApplication.class,args); }
}` 复制<br><br>在浏览器中输入 http://localhost:8081/insert?name=bjsxt 后,如果页面显示 1 并且数据库teacher 表和 student 表各增加一条数据表示新增成功。<br>
为了测试分布式事务效果，在 student_insert 项目实现类方法 return 上面添加 int i =5/0;的算术异常，再次访问 url 页面会报 500，并且数据库中没有新增数据，说明分布式事务成功了。<br>
<img alt="8732a6587350cc0eb0eeb98f82d18d54_MD5.png" src="https://pages-9hu.pages.dev/attachments/8732a6587350cc0eb0eeb98f82d18d54_md5.png" target="_self"><br><br>在上面 LCN 事务模式代码基础上进行修改<br><br><br>在当前项目中引入 mongodb 的依赖。如果在父项目中进行引入，则所有的子项目都需要配置 mongodb 的相关属性。<br>`&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;
&lt;/dependencies&gt;` 复制<br><br>新建 application.yml。<br>
虽然当前项目是连接 Mongodb 但是也需要配置 MySQL 数据源，因为 LCN 需要在 MySQL中记录异常信息等。<br>
配置文件中比别的项目多了 MongoDB 的配置。<br>`spring: datasource: url: jdbc:mysql://localhost:3306/microservice driver-class-name: com.mysql.jdbc.Driver username: root password: root application: name: mongodb-insert data: mongodb: authentication-database: admin username: bjsxt password: bjsxtpwd database: lcn host: 192.168.8.1 port: 27017
server: port: 8082
eureka: client: service-url: defaultZone: http://localhost:8761/eureka/
tx-lcn: client: manager-address: 127.0.0.1:8070` 复制<br><br>新建 com.bjsxt.pojo.People<br>`@Data
public class People { private String id; private String name;
}` 复制<br><br>新建 com.bjsxt.service.PeopleService 及实现类。<br>
具有@TccTransaction 注解的方法有以下特性<br>
<br>可以没有@Transactional
<br>如果整个分布式事务所有方法执行都没有异常，会回调名称为：confirm+方法名<br>
首字母大写的方法。insert 方法的回调方法叫做 confirmInsert()。同时方法参数也可以传递给回调方法。
<br>只要整个分布式事务中有一个方法出现异常，会回调 cancel+方法名首字母大写的回调方法。需要在这个方法中编写事务回滚的业务。
<br>`@TccTransaction 注解属性说明：
cancelMethod：明确指定失败的回调方法名
confirmMethod：明确指定成功的回调方法名` 复制<br>`public interface PeopleService { int insert(People people);
}` 复制<br>`@Service
public class PeopleServiceImpl implements PeopleService { @Autowired private MongoTemplate mongoTemplate; @Override @TccTransaction public int insert(People people) { People result = mongoTemplate.insert(people); if(result!=null){ return 1; } return 0; } public void cancelInsert(People people){ System.out.println("执行了 cancel 方法"+people); mongoTemplate.remove(people); System.out.println("所谓的事务回滚就是删除新增的数据"); } public void confirmInsert(People people){ System.out.println("执行了 confirm 方法"+people); }
}` 复制<br><br>新建 com.bjsxt.controller.PeopleController<br>`@Controller
public class PeopleController { @Autowired private PeopleService peopleService; @RequestMapping("/insert") @ResponseBody public int insert(People people){ return peopleService.insert(people); }
}` 复制<br><br>在浏览器输入 http://localhost:8082/insert?name=sxt 观察 mongodb 中是否出现了 lcn 的数据库，数据库中是否出现 People 的集合，people 集合中 name 属性值为sxt<br><br><br>新建 com.bjsxt.feign.MongodbInsertFeign。<br>
为了传递普通表单数据，<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=insert&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=insert&amp;spm=1001.2101.3001.7020" target="_self">insert</a> 方法参数由@RequestParam。mongodb_insert 控制器方法参数就可以使用 String name 或 People 进行接收。<br>`@FeignClient("mongodb-insert")
public interface MongodbInsertFeign { @RequestMapping("/insert") int insert(@RequestParam String name);
}` 复制<br><br>修改 com.bjsxt.service.impl.StudentServiceImpl。<br>
在实现类中调用 feign 接口的方法。<br>
当前方法依然使用 LCN 事务模式。方法上面加什么事务模式注解只考虑当前方法本地事务，不考虑调用远程方法的事务。如果当前方法中没有本地事务，全是调用远程方法，那么当前方法使用 LCN 或 TCC 事务模式都可以，但是必须要有事务模式，因为如果没有注解就不会想 TxManager 中创建事务组。<br>@Service
public class StudentServiceImpl implements StudentService { @Autowired private StudentMapper studentMapper; @Autowired private TeacherInsertFeign teacherInsertFeign; @Autowired private MongodbInsertFeign mongodbInsertFeign; @Override @LcnTransaction @Transactional public int insert(Student student) { Teacher teacher = new Teacher(); Random random = new Random(); teacher.setId((long)random.nextInt(10000)); teacher.setName("随意的名称"); student.setTid(teacher.getId()); student.setId((long)random.nextInt(10000 ) ) ; teacherInsertFeign.insert(teacher); mongodbInsertFeign.insert("随意的名称"); // int i = 5/0; return studentMapper.insert(student); }
} 复制<br>练习源码：<a rel="noopener" class="external-link is-unresolved" href="https://gitee.com/cutelili/tx-lcn" target="_self">https://gitee.com/cutelili/tx-lcn</a>]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/分布式事务架构/分布式事务处理【tx-lcn】.html</link><guid isPermaLink="false">知识库/工作技能/分布式/分布式事务架构/分布式事务处理【TX-LCN】.md</guid><pubDate>Mon, 15 Jul 2024 15:07:13 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/e20b04926c2ed678323ee8a91bad5f77_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/e20b04926c2ed678323ee8a91bad5f77_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LeetCode]]></title><link>https://pages-9hu.pages.dev/知识库/技术提升/leetcode/leetcode.html</link><guid isPermaLink="false">知识库/技术提升/LeetCode/LeetCode.md</guid><pubDate>Sun, 30 Jun 2024 14:43:07 GMT</pubDate></item><item><title><![CDATA[tomcat]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/tomcat-and-nginx/tomcat.html</link><guid isPermaLink="false">知识库/工作技能/运维/Tomcat And Nginx/tomcat.md</guid><pubDate>Sun, 30 Jun 2024 14:43:00 GMT</pubDate></item><item><title><![CDATA[maven]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/maven/maven.html</link><guid isPermaLink="false">知识库/工作技能/运维/Maven/maven.md</guid><pubDate>Sun, 30 Jun 2024 14:42:57 GMT</pubDate></item><item><title><![CDATA[Linux常用命令]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/linux/linux常用命令.html</link><guid isPermaLink="false">知识库/工作技能/运维/Linux/Linux常用命令.md</guid><pubDate>Sun, 30 Jun 2024 14:42:54 GMT</pubDate></item><item><title><![CDATA[Jenkins]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/jenkins/jenkins.html</link><guid isPermaLink="false">知识库/工作技能/运维/Jenkins/Jenkins.md</guid><pubDate>Sun, 30 Jun 2024 14:42:52 GMT</pubDate></item><item><title><![CDATA[docker]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/docker/docker.html</link><guid isPermaLink="false">知识库/工作技能/运维/Docker/docker.md</guid><pubDate>Sun, 30 Jun 2024 14:42:47 GMT</pubDate></item><item><title><![CDATA[sql server]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/数据库/sqlserver/sql-server.html</link><guid isPermaLink="false">知识库/工作技能/数据库/sqlserver/sql server.md</guid><pubDate>Sun, 30 Jun 2024 14:42:41 GMT</pubDate></item><item><title><![CDATA[redis]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/数据库/redis/redis.html</link><guid isPermaLink="false">知识库/工作技能/数据库/redis/redis.md</guid><pubDate>Sun, 30 Jun 2024 14:42:38 GMT</pubDate></item><item><title><![CDATA[mysql]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/数据库/mysql/mysql.html</link><guid isPermaLink="false">知识库/工作技能/数据库/mysql/mysql.md</guid><pubDate>Sun, 30 Jun 2024 14:42:35 GMT</pubDate></item><item><title><![CDATA[mongodb]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/数据库/mongodb/mongodb.html</link><guid isPermaLink="false">知识库/工作技能/数据库/mongodb/mongodb.md</guid><pubDate>Sun, 30 Jun 2024 14:42:33 GMT</pubDate></item><item><title><![CDATA[react]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/其他语言/react/react.html</link><guid isPermaLink="false">知识库/工作技能/其他语言/React/react.md</guid><pubDate>Sun, 30 Jun 2024 14:42:29 GMT</pubDate></item><item><title><![CDATA[python]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/其他语言/python/python.html</link><guid isPermaLink="false">知识库/工作技能/其他语言/Python/python.md</guid><pubDate>Sun, 30 Jun 2024 14:42:26 GMT</pubDate></item><item><title><![CDATA[nodeJs]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/其他语言/nodejs/nodejs.html</link><guid isPermaLink="false">知识库/工作技能/其他语言/NodeJs/nodeJs.md</guid><pubDate>Sun, 30 Jun 2024 14:42:24 GMT</pubDate></item><item><title><![CDATA[git page博客地址]]></title><description><![CDATA[<br><a rel="noopener" class="external-link is-unresolved" href="https://ro1992613.github.io/admin/index.html#/view/all" target="_self">https://ro1992613.github.io/admin/index.html#/view/all</a>]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/git/git-page博客地址.html</link><guid isPermaLink="false">知识库/工作技能/运维/GIT/git page博客地址.md</guid><pubDate>Sun, 30 Jun 2024 14:38:35 GMT</pubDate></item><item><title><![CDATA[cloudFlare博客地址]]></title><description><![CDATA[<br><a rel="noopener" class="external-link is-unresolved" href="https://pages-9hu.pages.dev/" target="_self">https://pages-9hu.pages.dev/</a><br><a rel="noopener" class="external-link is-unresolved" href="https://dash.cloudflare.com/" target="_self">https://dash.cloudflare.com/</a>]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/git/cloudflare博客地址.html</link><guid isPermaLink="false">知识库/工作技能/运维/GIT/cloudFlare博客地址.md</guid><pubDate>Sun, 30 Jun 2024 14:38:16 GMT</pubDate></item><item><title><![CDATA[git常用命令]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/git/git常用命令.html</link><guid isPermaLink="false">知识库/工作技能/运维/GIT/git常用命令.md</guid><pubDate>Sun, 30 Jun 2024 14:36:47 GMT</pubDate></item><item><title><![CDATA[RabbitMQ]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/消息队列/rabbitmq.html</link><guid isPermaLink="false">知识库/工作技能/分布式/消息队列/RabbitMQ.md</guid><pubDate>Sun, 30 Jun 2024 14:33:42 GMT</pubDate></item><item><title><![CDATA[Kafka]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/消息队列/kafka.html</link><guid isPermaLink="false">知识库/工作技能/分布式/消息队列/Kafka.md</guid><pubDate>Sun, 30 Jun 2024 14:33:14 GMT</pubDate></item><item><title><![CDATA[Kibana]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/elk日志分析系统/kibana.html</link><guid isPermaLink="false">知识库/工作技能/运维/ELK日志分析系统/Kibana.md</guid><pubDate>Sun, 30 Jun 2024 14:31:21 GMT</pubDate></item><item><title><![CDATA[Logstash]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/elk日志分析系统/logstash.html</link><guid isPermaLink="false">知识库/工作技能/运维/ELK日志分析系统/Logstash.md</guid><pubDate>Sun, 30 Jun 2024 14:31:13 GMT</pubDate></item><item><title><![CDATA[Elasticsearch]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/elk日志分析系统/elasticsearch.html</link><guid isPermaLink="false">知识库/工作技能/运维/ELK日志分析系统/Elasticsearch.md</guid><pubDate>Sun, 30 Jun 2024 14:30:49 GMT</pubDate></item><item><title><![CDATA[金丝雀部署]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/其他/金丝雀部署.html</link><guid isPermaLink="false">知识库/工作技能/运维/其他/金丝雀部署.md</guid><pubDate>Sun, 30 Jun 2024 14:29:39 GMT</pubDate></item><item><title><![CDATA[Skyworking 链路追踪]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/其他架构/skyworking-链路追踪.html</link><guid isPermaLink="false">知识库/工作技能/其他架构/Skyworking 链路追踪.md</guid><pubDate>Sun, 30 Jun 2024 14:28:39 GMT</pubDate></item><item><title><![CDATA[LiquiBase 数据库版本控制工具]]></title><link>https://pages-9hu.pages.dev/知识库/工作技能/其他架构/liquibase-数据库版本控制工具.html</link><guid isPermaLink="false">知识库/工作技能/其他架构/LiquiBase 数据库版本控制工具.md</guid><pubDate>Sun, 30 Jun 2024 14:26:56 GMT</pubDate></item><item><title><![CDATA[seata地址]]></title><description><![CDATA[<br><a rel="noopener" class="external-link is-unresolved" href="https://seata.apache.org/zh-cn/" target="_self">https://seata.apache.org/zh-cn/</a>]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/分布式/分布式事务架构/seata地址.html</link><guid isPermaLink="false">知识库/工作技能/分布式/分布式事务架构/seata地址.md</guid><pubDate>Sun, 30 Jun 2024 14:22:22 GMT</pubDate></item><item><title><![CDATA[arthas地址]]></title><description><![CDATA[<br><a rel="noopener" class="external-link is-unresolved" href="https://arthas.aliyun.com/" target="_self">https://arthas.aliyun.com/</a>]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/运维/arthas/arthas地址.html</link><guid isPermaLink="false">知识库/工作技能/运维/Arthas/arthas地址.md</guid><pubDate>Sun, 30 Jun 2024 14:15:41 GMT</pubDate></item><item><title><![CDATA[常用网站]]></title><description><![CDATA[<br><a data-tooltip-position="top" aria-label="https://www.waifu2x.net/" rel="noopener" class="external-link is-unresolved" href="https://www.waifu2x.net/" target="_self">waifu2x</a>]]></description><link>https://pages-9hu.pages.dev/知识库/日常技能/常用网站.html</link><guid isPermaLink="false">知识库/日常技能/常用网站.md</guid><pubDate>Sun, 30 Jun 2024 13:55:31 GMT</pubDate></item><item><title><![CDATA[常用句型收集]]></title><description><![CDATA[<br>
<br>
Am I allowed to 我可以……吗 <br>
As matter of fact 实际上…… <br>
As far as I m concerned 就我而言 <br>
As far as I know 据我所知 <br>
As I just mentioned 正如我刚才提到过的 <br>
As I see it 在我看来 <br>
As is known to us all 众所周知,…… <br>
As long as 只要… <br>
But for... 若不是因为;如果没有…… <br>
Can you believe (that) 你相信……吗 <br>
Can you imagine 你能想像……吗 <br>
Could you please explain 你能解释一下……吗 <br>
Can t we... 难道我们不能……吗 <br>
Could you do me a favor and... 能否请你帮我一个忙… <br>
Do you by any chance know... 你(碰巧)知道……吗 <br>
Do you enjoy doing... 你喜欢做……吗 <br>
Do you happen to know... 你(碰巧)知道……吗 <br>
Do you have any good ways to... 你有没有……的好办法 <br>
Did you know (that)... 你知道……吗 <br>
Do you know if (whether)... 你知道是否…… <br>
Do (Would) you mind doing... 你介意做……吗 <br>
Do (Would) you mind if... 如果……你是否介意 <br>
Do you realize (that)... 你有没有意识到…… <br>
Do you think it is possible to... 你认为……可能吗 <br>
Do you think it necessary to... 你认为有必要……吗 <br>
doesn t make sense 没有道理/没有意义/不清楚 <br>
Don t be afraid of...不要害怕…… <br>
Don t take it for granted that...别认为……理所当然 <br>
Don t waste time doing...不要浪费时间做…… <br>
Don t you think that...难道你不认为……吗 <br>
Excuse me for...请原谅我…… <br>
For one thing For another 一方面……;另一方面……. <br>
From my point of view 在我看来,…… <br>
From where I stand 从我的立场来说…… <br>
Generally speaking 总的来说…… <br>
Hardly when...一……就……. [倒装句型] <br>
Have you considered doing...你有没有考虑过做…… <br>
Have you decided...你决定好……了吗 <br>
Have you ever been to...你曾经去过……吗 <br>
Have you thought about(of) ...你有没有想过…… <br>
Haven t you heard of ...难道你没听说过……吗 <br>
How are you getting on (along) with... ……进展如何/与……相处如何 <br>
How are you going to...你打算如何…… <br>
How does sound (听起来)怎么样 <br>
How long will it take you to...要用多长时间 <br>
How should I...我该如何…… <br>
I absolutely agree with我完全同意… <br>
I absolutely agree with我完全同意… <br>
I m grateful for...我对……特别感激 <br>
I am planning to 我打算…… <br>
I am very pleased to have this opportunity to...我很高兴有机会… <br>
I apologize for...我为……道歉 <br>
I believe (that) 我相信…… <br>
I believe we should...我认为我们应该…… <br>
I can t imagine...我无法想像… <br>
I can t stand it when...我无法忍受…… <br>
I didn t expect to...我没想到…… <br>
I didn t mean to...我不是有意…… <br>
I didn t realize...我不知道…….俄没意识到…… <br>
I (don t) feel like...我(不)想…… <br>
I don t get very excited about...我对……不怎么感兴趣. <br>
I don t know how to...我不知道如何…… <br>
I don t see (that)...我看不出/我认为不……. <br>
I don t think it is necessary to...我认为没有必要…… <br>
I don t think it s right to...我认为……是不对的. <br>
I doubt that if (whether)...我怀疑/我不相信…… <br>
I dream of...我梦想…… <br>
I m dying to...我渴望…….俄盼望…… <br>
I feel very honored to...我觉得很荣幸…… <br>
I m fed up with...我厌倦了…….我受够了…… <br>
I m sick and tired of...我对……感到厌烦. <br>
I find it hard for me to...我发现……对我来说很难 <br>
I hate to disagree with you, but...我不想跟你有不同意见,但是…… <br>
I have confidence in...我相信…….我对……有信心. <br>
I have nothing to do with...我与……无关. <br>
I have no experience in...我在……方面没有经验 <br>
I haven t (done)... for a long time我很久没有……了 <br>
I insist that...我坚决要求…… <br>
I insist on (doing) 我坚持…… <br>
I intend to我打算…… <br>
I like nothing better than...我喜欢……胜过任何东西 <br>
I never dreamed of 我从未想过…… <br>
I prefer... to 我喜欢……甚于… <br>
I prefer to... rather than...我宁愿…...而不愿 <br>
I really want to know...我真的很想知道…… <br>
I set my mind to do sth (on sth)我下定决心……. <br>
I sincerely hope that...我真诚地希望…… <br>
I strongly advise you to...我强烈建议你…… <br>
I suggest (that)...我建议…… <br>
I think this is a good chance for you to...我认为这是你...的一个好机会 <br>
I think it is a good idea to...我认为……是个好主意 <br>
I think it is a waste of money (time) doing...我觉得……是浪费金钱/时间. <br>
I think it s wrong to...我认为……是不对的. <br>
I think that it is impossible to...我觉得……是不可能的. <br>
I think you might like to...我想你可能会喜,灯想…… <br>
I think you d better...我觉得你最好…… <br>
I want to express my gratitude to...我要感谢…… <br>
I was impressed by...我被……打动了;……给我留下深刻印象. <br>
I (wonder) was wondering if...我想知道…/我在想是否… <br>
I demanded (that)...我要求…… <br>图片<br>
<br>
I won t...unless 除非……否则我不会… <br>
I used to...我过去常常…… <br>
I would advise you to...我会建议你…… <br>
I would appreciate it if...如果……,我会非常感激. <br>
I would like to recommend...我想推荐…… <br>
I would like to... rather than...我宁愿……也不…… <br>
I would rather...than...我宁愿……,而不愿…… <br>
I wouldn t feel happy if...如果……我会不高兴的 <br>
I d be happy to if you d like如果你愿意,我很高兴… <br>
I d like to know more about...我想了解更多关于… <br>
I d like to suggest you do...我想建议你… <br>
I d like (love) to, but...我很想,但…… <br>
I m (not) certain...我(不)确定…… <br>
I m afraid I won t be able to...恐怕我不能… <br>
I m busy with (doing)...我正忙于…… <br>
I m considering (doing)...我正考虑… <br>
I m convinced that...我确信… <br>
I m curious to (do) about...我对(做)……很好奇 <br>
I m determined to...我决定… <br>
I m getting a little concerned about...我对……有点担忧. <br>
I m interested in...我对……感兴趣 <br>
I m (just) calling to...我打电话来是要… <br>
I m (not) sure...我(不是)很确定… <br>
I m not very interested in...我对……不是很感兴趣 <br>
I m occupied (with)...我忙于… <br>
I m really fond of...我的确喜欢… <br>
I m really (terribly) sorry for...我对……感到非常抱歉 <br>
I ve been thinking about...我一直想… <br>
I have a desire to...我非常渴望… <br>
I ve decided to...我已经决定… <br>
If I did..., I would...如果我……,我会… <br>
If I had done..., I would have done...如果我……,我就会… <br>
If I were you... I would...如果我是你……,我就会… <br>
If only...! 真希望……!若是……那该多好啊! <br>
If it is possible 可能的话… <br>
If you ask me, I think...如果你问我,我认为… <br>
If you want to...you ll have to...如果你想……,你将不得不… <br>
In a word...总之,… <br>
In brief (short) ...简言之,…… <br>
In conclusion, ...最后,…….聪之,…… <br>
In general —般而言,…… <br>
In my opinion (view) 我认为…… <br>
In order to you should...为了…·你应该 <br>
In other words 换句话说…… <br>
In that case 既然那样 <br>
...is of great importance...很重要 <br>
Is it convenient for you to...你是否方便… <br>
Is it OK if…如果……可以吗 <br>
Is it possible to...有可能吗 <br>
Is there a better way to 有没有更好的方法 <br>
Is there any chance you could possibly 你有没有可能 <br>
Is there anything else that 还有别的吗 <br>
It appears that 看来,/ 似乎 <br>
It depends on whether这取决于……是否 <br>
It doesn t make sense to 没有任何意义 <br>
It doesn t matter whether (if) 如果……也没关系. <br>
It goes without saying that 理应如此/不言而喻. <br>
It makes a (no) difference (to sb.) (对某人来说)……很重要/无所谓 <br>
It occurred to me that 浮现于我的脑中.我想起 <br>
It won t do any harm to 没有坏处 <br>
It would be wonderful if 要是……那就太好了 <br>
It happened that 很偶然 <br>
It helps if 如果……的话,将会(对某人)有帮助/好处 <br>
It s amazing (that) 很了不起 <br>
It is bad to 是不好的 <br>
It s hard to imagine 很难想像 <br>
It is believed that 人们认为… <br>
It didn t (won t) take long before...没多久/不需要多久……就 <br>
It is easier to... than to比.....容易 <br>
It is easy enough to 相当容易 <br>
It is essential that...有必要… <br>
It is good manners to do 是有礼貌的表现. <br>
It is high time ...现在是……的时候了;早就应该……了 <br>
It is hoped that...希望 <br>
It is important that 是很重要的 <br>
It s long been my dream to 一直是我的梦想 <br>
It is (very /not) likely that...(很/没)有可能 <br>
It is (not) necessary to 是(没)有必要的 <br>
It is no use doing sth. 做某事是毫无用处的 <br>
It is not unusual for sb to do...某人做……不足为奇 <br>
It is possible (impossible) to 是(不)可能的 <br>
It is dangerous to 危险 <br>
It is (rather) common to do...(相当)普遍 <br>
It is reported that...据说;据报导 <br>
lt is required that 要求… <br>
It is said that 据说… <br>
It is thought that...人们认为… <br>
It is (not) true that (不)是真的. <br>
It is (very) difficult to (非常)困难. <br>
It s really a challenge for me to 对我来说确实是一个挑战 <br>
It is (very) useful to 很有用 <br>
It is (was) obvious (clear) that...很明显… <br>
It seems (seemed) that...好像…….似乎… <br>
It sounds like 听起来好像… <br>
It takes sb some time (money) to do sth.某人花多长时间/多少钱做某事 <br>
It wasn t until that...直到……才 <br>
It would be wonderful if...如果……那就太好了 <br>
It s not (just) like sb to do sth...的行为不/正像某人的一贯作风 <br>
lt s a bad habit to 是一个坏习惯 <br>
It s a great pleasure to (感到)非常愉快 <br>图片<br>
<br>
It s customary to...是习惯 <br>
It s delightful to 令人很高兴 <br>
lt s my great honor to 是我莫大的荣幸 <br>
It s (not) good to...(不)好 <br>
It s our duty to...……是我们的责任 <br>
It s wrong to…是不对的 <br>
It s a shame (pity) that...可惜/遗憾…… <br>
It is (really) unbelievable that……(真)让人难以置信 <br>
It is (will be) difficult to……(会)很难 <br>
It ll do you good to……对你有好处 <br>
Last but not least 最后但同样重要的是…… <br>
Let me explain why 让我解释为什么…… <br>
Let me fill you in on...让我来告诉你…… <br>
(Just) let me know if...如果……,请告诉我 <br>
Let me see if...让我看看是否…… <br>
Make sure to do sth —定要做某事 <br>
Maybe it s better to...可能……会更好一些 <br>
means a great deal to me 对我意义重大 <br>
My dream (goal) (plan) is...我的梦想/目标/希望所划是… <br>
My point of view is that...我的观点是…… <br>
no matter what...无论什么… <br>
no one can deny that...没有人能够否认… <br>
no sooner...than...一……就…… <br>
no words can express...语言难以表达……;……难以言表 <br>
Not until...did...直到……才…… <br>
Now that 既然/由于…… <br>
On the condition that 条件是… <br>
On the contrary 正好相反 <br>
On (the) one hand on the other (hand) 一方面……,另一方面… <br>
One of the is 最……之一的就是…… <br>
Personally, I think ( believe) (feel)...我个人认为/相信/感觉… <br>
Please don t hesitate to...请随时 <br>
Please feel free to 请随时 <br>
Please forgive me for 请原谅我 <br>
Please give my best wishes to...请代我问候 <br>
Recent studies show that...最近研究表明… <br>
Sb. can do nothing but do...除了做……,某人什么也做不了 <br>
Sb. have no choice but to do...某人除了做……别无选择 <br>
Sb. look(s) as if...某人看上去好像 <br>
Something must be done to必须采取措施 <br>
Sorry to bother you, but 很抱歉打扰你,可是 <br>
Thanks to...由于…/多亏 <br>
The point is...重点/关键是 <br>
The problem is that问题是… <br>
The reason why... is…的原因就是… <br>
The secret of...is to......的秘诀是... <br>
The way I see it 我的看法是… <br>
This was the moment when…就是那个时候… <br>
That reminds me 那提醒了我……;那让我想起了 <br>
There are signs that...有……的迹象/征兆.有迹象表明/显示… <br>
There is no doubt that...毫无疑问 <br>
There seems to be...看起来好像 <br>
There used to be...过去曾有……;曾经有过 <br>
There s no point in...是无意义的 <br>
There s no way...绝不可能 <br>
To a great/some extent 在很大/某种程度上 <br>
To be frank / honest 老实说,…….说实话 <br>
To one s delight 让某人高兴/惊奇的是 <br>
To start with 首先 <br>
To sum up...总之,…….总而言之 <br>
To tell (you) the truth说实话 <br>
We hold the opinion that...我们认为 <br>
We must do something to...我们必须采取行动以 <br>
We must take action (measures) to...我们必须采取行动/措施以 <br>
We should make every effort to...我们应该竭尽全力 <br>
What do you find the hardest in...你觉得……最大的困难是什么 <br>
What do you mean by...你……是什么意思 <br>
What do you say...你认为……怎么样 <br>
What do you think of...你认为……怎么样 <br>
What I m getting at is...我的意思是 <br>
What is more serious is that...更严重的是 <br>
What s the point of...意义何在 为什么要 <br>
What makes you think...是什么让你认为…;你为什么认为 <br>
What seems to be the problem with...大概是什么问题 <br>
What seems to be the trouble is...好像问题在于 <br>
What surprised me is that...令我吃惊的是 <br>
What will you do if...如果……,你会做什么 <br>
What you have to do is...你必须做的是 <br>
What would you say /think of...你认为……怎么样 <br>
When do you want me to...你想让我在什么时候 <br>
When it comes to...谈到…;涉及到 <br>
When will it be convenient for you to...你看什么时候方便 <br>
Would you be so kind as to...能否请你… <br>
Would you like to...你想……吗 <br>
You are expected to...你要;应该 <br>
You are (not) allowed to...(不)允许你 <br>
You are (not) permitted to...(不)允许你 <br>
You are required to要求你 <br>
You are supposed to...你应该 <br>
You don t have to 你没必要 <br>
You don t need to 你没必要 <br>
You really have to do something about...你的确应该处理一下；你真得为…...做点什么了 <br>
You should avoid doing sth.你应该避免做某事 <br>
You should make an effort to...你应该努力 <br>
You should make good use of...你应该充分利用 <br>
You should never...你绝不应该 <br>
You were (not) supposed to...你本(不)应该 <br>
You will be able to... if...如果……,你将能够 <br>
You ll never guess...你永远猜不到 <br>
You ll never think of...你绝不会想到 ]]></description><link>https://pages-9hu.pages.dev/知识库/英语/常用句型收集.html</link><guid isPermaLink="false">知识库/英语/常用句型收集.md</guid><pubDate>Sun, 23 Jun 2024 16:04:36 GMT</pubDate></item><item><title><![CDATA[知识库]]></title><description><![CDATA[<br><br><br><br>]]></description><link>https://pages-9hu.pages.dev/index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 19 Jun 2024 16:04:19 GMT</pubDate></item><item><title><![CDATA[Spring 事务（编程式事务、声明式事务@Transactional、事务隔离级别、事务传播机制)]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="1\. 事务的定义" data-href="#1\. 事务的定义" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#1/._事务的定义" class="internal-link" target="_self" rel="noopener">1\. 事务的定义</a>
<br><a data-tooltip-position="top" aria-label="2\. Spring 中事务的实现" data-href="#2\. Spring 中事务的实现" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2/._Spring_中事务的实现" class="internal-link" target="_self" rel="noopener">2\. Spring 中事务的实现</a> <br><a data-tooltip-position="top" aria-label="2.1 MySQL 中使用事务" data-href="#2.1 MySQL 中使用事务" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.1_MySQL_中使用事务" class="internal-link" target="_self" rel="noopener">2.1 MySQL 中使用事务</a>
<br><a data-tooltip-position="top" aria-label="2.2 Spring 中编程式事务的实现" data-href="#2.2 Spring 中编程式事务的实现" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.2_Spring_中编程式事务的实现" class="internal-link" target="_self" rel="noopener">2.2 Spring 中编程式事务的实现</a>
<br><a data-tooltip-position="top" aria-label="2.3 Spring 中声明式事务" data-href="#2.3 Spring 中声明式事务" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3_Spring_中声明式事务" class="internal-link" target="_self" rel="noopener">2.3 Spring 中声明式事务</a> <br><a data-tooltip-position="top" aria-label="2.3.1 声明式事务的实现 @Transactional" data-href="#2.3.1 声明式事务的实现 @Transactional" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3.1_声明式事务的实现_@Transactional" class="internal-link" target="_self" rel="noopener">2.3.1 声明式事务的实现 @Transactional</a>
<br><a data-tooltip-position="top" aria-label="2.3.2 @Transactional 作用域" data-href="#2.3.2 @Transactional 作用域" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3.2_@Transactional_作用域" class="internal-link" target="_self" rel="noopener">2.3.2 @Transactional 作用域</a>
<br><a data-tooltip-position="top" aria-label="2.3.3@Transactional 参数设置" data-href="#2.3.3@Transactional 参数设置" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3.3@Transactional_参数设置" class="internal-link" target="_self" rel="noopener">2.3.3@Transactional 参数设置</a>
<br><a data-tooltip-position="top" aria-label="2.3.4 @Transactional 异常情况" data-href="#2.3.4 @Transactional 异常情况" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3.4_@Transactional_异常情况" class="internal-link" target="_self" rel="noopener">2.3.4 @Transactional 异常情况</a>
<br><a data-tooltip-position="top" aria-label="2.3.5 @Transactional 工作原理" data-href="#2.3.5 @Transactional 工作原理" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#2.3.5_@Transactional_工作原理" class="internal-link" target="_self" rel="noopener">2.3.5 @Transactional 工作原理</a> <br><a data-tooltip-position="top" aria-label="3\. 事务隔离级别" data-href="#3\. 事务隔离级别" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#3/._事务隔离级别" class="internal-link" target="_self" rel="noopener">3\. 事务隔离级别</a> <br><a data-tooltip-position="top" aria-label="3.1 事务特性" data-href="#3.1 事务特性" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#3.1_事务特性" class="internal-link" target="_self" rel="noopener">3.1 事务特性</a>
<br><a data-tooltip-position="top" aria-label="3.2 Spring 中设置事务隔离级别" data-href="#3.2 Spring 中设置事务隔离级别" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#3.2_Spring_中设置事务隔离级别" class="internal-link" target="_self" rel="noopener">3.2 Spring 中设置事务隔离级别</a> <br><a data-tooltip-position="top" aria-label="4\. Spring 事务传播机制" data-href="#4\. Spring 事务传播机制" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4/._Spring_事务传播机制" class="internal-link" target="_self" rel="noopener">4\. Spring 事务传播机制</a> <br><a data-tooltip-position="top" aria-label="4.1 事务传播机制是什么" data-href="#4.1 事务传播机制是什么" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.1_事务传播机制是什么" class="internal-link" target="_self" rel="noopener">4.1 事务传播机制是什么</a>
<br><a data-tooltip-position="top" aria-label="4.2 为什么需要事务传播机制" data-href="#4.2 为什么需要事务传播机制" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.2_为什么需要事务传播机制" class="internal-link" target="_self" rel="noopener">4.2 为什么需要事务传播机制</a>
<br><a data-tooltip-position="top" aria-label="4.3 事务传播机制有哪些" data-href="#4.3 事务传播机制有哪些" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.3_事务传播机制有哪些" class="internal-link" target="_self" rel="noopener">4.3 事务传播机制有哪些</a>
<br><a data-tooltip-position="top" aria-label="4.4 Spring 事务传播机制使用" data-href="#4.4 Spring 事务传播机制使用" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4_Spring_事务传播机制使用" class="internal-link" target="_self" rel="noopener">4.4 Spring 事务传播机制使用</a> <br><a data-tooltip-position="top" aria-label="4.4.1 支持当前事务（REQUIRED 默认）" data-href="#4.4.1 支持当前事务（REQUIRED 默认）" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4.1_支持当前事务（REQUIRED_默认）" class="internal-link" target="_self" rel="noopener">4.4.1 支持当前事务（REQUIRED 默认）</a>
<br><a data-tooltip-position="top" aria-label="4.4.2 不支持当前事务（REQUIRES_NEW）" data-href="#4.4.2 不支持当前事务（REQUIRES_NEW）" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4.2_不支持当前事务（REQUIRES_NEW）" class="internal-link" target="_self" rel="noopener">4.4.2 不支持当前事务（REQUIRESNEW）</a>
<br><a data-tooltip-position="top" aria-label="4.4.3 不支持当前事务（NOT_SUPPORTED）" data-href="#4.4.3 不支持当前事务（NOT_SUPPORTED）" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4.3_不支持当前事务（NOT_SUPPORTED）" class="internal-link" target="_self" rel="noopener">4.4.3 不支持当前事务（NOTSUPPORTED）</a>
<br><a data-tooltip-position="top" aria-label="4.4.4 NESTED 嵌套事务" data-href="#4.4.4 NESTED 嵌套事务" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4.4_NESTED_嵌套事务" class="internal-link" target="_self" rel="noopener">4.4.4 NESTED 嵌套事务</a>
<br><a data-tooltip-position="top" aria-label="4.4.5 嵌套事务和加入事务的区别" data-href="#4.4.5 嵌套事务和加入事务的区别" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html#4.4.5_嵌套事务和加入事务的区别" class="internal-link" target="_self" rel="noopener">4.4.5 嵌套事务和加入事务的区别</a> <br>
本篇重点总结： <br>在 Spring 项目中使用事务，有两种方式：编程式手动操作和声明式自动提交，声明式自动提交使用最多，只需要在方法上添加注解 @Transactional
<br>设置事务的隔离级别 @Transactional(isolation = Isolation.SERIALIZABLE)，Spring 中的事务隔离级别有5种
<br>设置事务的传播机制 @Transactional(propagation = Propagation.REQUIRED)，Spring 中的事务传播级别有 7 种 <br><br>事务定义：将一组操作封装成一个执行单元（封装到一起），要么全部成功，要么全部失败<br>那么为什么要用事务呢<br>比如两个银行账户之间的转账操作：<br>
<br>第一步操作：A 账户 -100 元
<br>第二步操作：B 账户 +100 元
<br>如果没有事务。第一步执行成功了，第二步执行失败了，那么 A 账号就丢失了 100 元，而如果使用事务就可以解决这个问题，让这一组操作要么一起成功，要么一起失败<br><br><br>Sping 中事务的操作用两种：<br>
<br>编程式事务（手写代码操作事务）
<br>声明式事务（利用注解自动开启和提交事务）
<br><br>MySQL 中事务有 3 个重要的操作：开启事务、提交事务、回滚事务，它们对应的操作命令如下<br>`-- 开启事务
start transaction; -- 业务执⾏
-- 提交事务
commit;
-- 回滚事务
rollback;` 复制<br><br><br>Spring 中手动操作事务和 <a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=MySQL%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=MySQL%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020" target="_self">MySQL操作</a>事务类似，也是有 3 个重要操作<br>
<br>开启事务（获取事务）
<br>提交事务
<br>回滚事务
<br>Spring Boot 内置了两个对象，DataSourceTransactionManager （事务管理器）用来获取事务（开启事务）、提交或回滚事务的，而 TransactionDefinition 是事务的属性，在获取事务的时候需要将 TransactionDefinition 传递进去从而获得一个事务 TransactionStatus 对象<br>`@RestController
public class UserController { @Autowired private UserService userService; @Autowired private DataSourceTransactionManager transactionManager; @Autowired private TransactionDefinition transactionDefinition; @RequestMapping("/add") public int add(UserInfo userInfo) { if(userInfo==null || !StringUtils.hasLength(userInfo.getUsername()) || !StringUtils.hasLength(userInfo.getPassword())) { return 0; } TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition); int result = userService.add(userInfo); System.out.println("add 受影响的行数：" + result); transactionManager.commit(transactionStatus); return result; }
}` 复制<br>运行程序分别查看提交事务和回滚事务的效果<br><img src="https://img-blog.csdnimg.cn/7b15deb5bae6435e84ce0ddd7b3d8ece.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://img-blog.csdnimg.cn/f29367abeea441659e1dd211316df6c1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br><br>声明式事务的实现，只需要在方法上添加 @Transactional 注解就可以实现，无序手动开启事务和提交事务，进入方法时自动开启事务，方法执行完全会自动提交事务，如果中途发生了没有处理的异常会自动回滚事务<br> `@Transactional
@RequestMapping("/add2")
public int add2(UserInfo userInfo) { if(userInfo==null || !StringUtils.hasLength(userInfo.getUsername()) || !StringUtils.hasLength(userInfo.getPassword())) { return 0; } int result = userService.add(userInfo); System.out.println("add2 受影响的行数：" + result); int num = 10/0; return result;
}` 复制<br><img src="https://img-blog.csdnimg.cn/edfafdcdc46c44489736d1eaec8ec12c.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>去除异常的那行代码重新运行程序<br><img src="https://img-blog.csdnimg.cn/c518198bb0094216b9da591ce7a8984f.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>@Transactional 可以用来修饰方法或类：<br>
<br>修饰方法时，只能应用到 public 方法上，否则不生效
<br>修饰类时，说明该注解对该类中所有的 public 方法都生效
<br><br><br><br>设置事务的隔离级别<br><img src="https://img-blog.csdnimg.cn/690cdff0ba8143a3a6d5d9d9006d1d55.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>设置事务的超时时间<br><img src="https://img-blog.csdnimg.cn/7aa5e93a539a4e2da0c7e2e95f5c1717.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>@Transactional 在异常被捕获的情况下，不会进⾏事务⾃动回滚<br>`@Transactional
@RequestMapping("/add3")
public int add3(UserInfo userInfo) { if(userInfo==null || !StringUtils.hasLength(userInfo.getUsername()) || !StringUtils.hasLength(userInfo.getPassword())) { return 0; } int result = userService.add(userInfo); System.out.println("add2 受影响的行数：" + result); try { int num = 10/0; } catch (Exception e) { } return result;
}` 复制<br><img src="https://img-blog.csdnimg.cn/75678e7732094e52bf196c3e42fe1623.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>解决方法1：将异常重新抛出去<br>对于捕获的异常，事务是会⾃动回滚的，因此解决⽅案1就是将异常重新抛出<br><img src="https://img-blog.csdnimg.cn/45912c55eb5c4901a9a185986f014af0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>解决方法2：使用代码的方式手动回滚当前事务<br>手动回滚事务，在⽅法中使⽤ TransactionAspectSupport.currentTransactionStatus() 可以得到当前的事务，然后设置回滚方法 setRollbackOnly 就可以实现回滚了，具体实现代码<br> `@Transactional @RequestMapping("/add3") public int add3(UserInfo userInfo) { if(userInfo==null || !StringUtils.hasLength(userInfo.getUsername()) || !StringUtils.hasLength(userInfo.getPassword())) { return 0; } int result = userService.add(userInfo); System.out.println("add2 受影响的行数：" + result); try { int num = 10/0; } catch (Exception e) { TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); } return result; }` 复制<br><img src="https://img-blog.csdnimg.cn/417e21b1a4804d4586917c0515030f88.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>@Transactional 是基于 AOP 实现的，AOP 又是使用动态代理来实现的。如果目标对象实现了接口，默认情况下采用 JDK 的动态代理，如果目标对象没有实现接口，会使用 CGLIB 动态代理。@Transactional 在开始执行业务之前，通过代理先开启事务，在执行成功之后再提交事务，如果中途遇到异常，则回滚事务<br>@Transactional 实现思路<br><img src="https://img-blog.csdnimg.cn/21db7f254e46456dbaf1e165cde2480a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>@Transactional 具体执行细节<br><img src="https://img-blog.csdnimg.cn/704662ba606e43598028475a379cd3e0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br><br>事务有四大特性（ACID），原子性、持久性、一致性和隔离性<br>
<br>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成。不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态
<br>一致性（Consistency）：在事务开始之前和事务事务结束之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精准度、串联性以及后续数据库可以自发性地完成预定的工作
<br>持久性（Isolation）：事务处理结束后，对数据的修改就是永久的。即使系统故障也不会丢失
<br>隔离性（Durability）：数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由交叉执行而导致数据的不一致。
<br>这四个特性中，只有隔离性（隔离级别）是可以设置的<br><br><br>为什么要设置事务的隔离级别<br>设置事务的隔离级别是用来保障多个并发事务执行更可控，更符合操作者预期的<br>这个可控表示的是，比如疫情的时候，有确诊、密接、次密接等针对不同的人群，采取不同的隔离级别，这种方式与事务的隔离级别类似，都是让某种行为操作变的 更可控，事务的隔离级别就是为了防止，其他事务影响当前事务执行的一种策略<br>MySQL 事务隔离级别有 4 种<br>
<br>读未提交（READ UNCOMMITTED ）：事务A读到了事务B没有提交的数据，然后过了一会事务B进行了回滚，此时事务A的这个情况就叫脏读，读到的数据也叫脏数据，读未提交侧重于查询，既然有了脏读，那么也肯定有不可重复读和幻读的问题
<br>读已提交（READ COMMITTED）：针对上面脏读的问题来解决的，事务A读到了事务B已经提交的数据，然后过了一会事务B将提交的数据进行修改了，此时事务A又读了一次B的数据，发现两次读到读到数据不一样，这个就叫不可重复读的问题，读已提交侧重的是修改，还是存在不可重复读和幻读的问题
<br>可重复读（REPEATABLE READ） ：针对的是上面不可重复读的问题，事务A此时查询数据发现表中只有一条数据，然后事务B又过来拆台了，事务B又插入了一条数据，事务A再次查询发现，哎！我出现幻觉了吗，刚刚不是只有一条数据么，现在咋又变成了两条数据了，是出现幻觉了吗，这个问题就叫 幻读，可重复读侧重的是添加和删除，只存在幻读的问题了
<br>串行化（SERIALIZABLE）：事务最高的隔离级别，解决了脏读、不可重复读、幻读的问题，但这个级别执行效率低
<br><br>Spring 中事务隔离级别有 5 种<br>多了一个默认事务隔离级别 DEFAULT 以连接的数据库事务隔离级别为准，如果连接的是 MySQL 那么默认就是 可重复读<br>注意事项：<br>
<br>当 Spring 中设置了事务隔离级别和连接的数据库（MySQL）事务隔离级别发送冲突的时候，以Spring为准
<br>Spring 中的事务隔离级别机制的实现是依靠连接数据库支持事务隔离级别为基础
<br>Spring 中事务隔离级别可以通过 @Transactional 中的 isolation 属性进行设置<br><br><br><br>Spring 事务传播机制：多个事务在相互调用时，事务是如何传递的<br><br>事务隔离级别是保证多个并发事务执⾏的可控性的（稳定性的），⽽事务传播机制是保证⼀个事务在多个调⽤⽅法间的可控性的（稳定性的）<br><img src="https://img-blog.csdnimg.cn/8bd9584e0af346958f6e06f5ee0c1133.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br>事务的传播机制有 7 种：<br><img src="https://img-blog.csdnimg.cn/a1b28021c25643c88539506abfe3dc1a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<br>Propagation.REQUIRED：默认的事务传播级别，它表示如果当前存在事务，则加入事务；如果当前没有事务，则创建一个新的事务
<br>Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行
<br>Propagation.MANDATORY；（mandatory 强制性）如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常
<br>Propagation.REQUIRES_ENW：表示创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰
<br>Propagation.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起
<br>Propagation.NEVER：以非事务方式运行，如果当前存在事务，则抛出异常
<br>Propagation.NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED
<br><img src="https://img-blog.csdnimg.cn/0ddf624fe3e243faa4d92d5780260335.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>在mycnblog数据库中，先创建一个表<br>``mysql&gt; create table loginfo( -&gt; id int primary key auto_increment, -&gt; name varchar(250), -&gt; `desc` text, -&gt; createtime datetime default CURRENT_TIMESTAMP);
Query OK, 0 rows affected (0.04 sec) mysql&gt; desc loginfo;
+
| Field | Type | Null | Key | Default | Extra |
+
| id | int(11) | NO | PRI | NULL | auto_increment |
| name | varchar(250) | YES | | NULL | |
| desc | text | YES | | NULL | |
| createtime | datetime | YES | | CURRENT_TIMESTAMP | |
+
4 rows in set (0.00 sec)`` 复制<br>以下代码实现中，先开启事务先成功插入一条用户数据，然后再执行日志报错，而在日志报错是发生了异常，观察 propagation = Propagation.REQUIRED 的执行结果<br>`@RestController
public class UserController { @Autowired private UserService userService; @Autowired private LogService logService; @Transactional(propagation = Propagation.REQUIRED) @RequestMapping("/add4") public int add4(UserInfo userInfo) { if(userInfo == null || !StringUtils.hasLength(userInfo.getUsername()) || !StringUtils.hasLength(userInfo.getPassword())) { return 0; } int userResult = userService.add(userInfo); System.out.println("添加用户：" + userResult); LogInfo logInfo = new LogInfo(); logInfo.setName("添加用户"); logInfo.setDesc("添加用户结果：" + userResult); int logResult = logService.add(logInfo); return userResult; }
}` 复制<br><img src="https://img-blog.csdnimg.cn/5859abcfe6ef418da5b386c5df360fe7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>执行结果：程序报错，数据库没有插⼊任何数据<br>执行流程<br>
<br>UserService 中的保存⽅法正常执⾏完成。
<br>LogService 保存⽇志程序报错，因为使⽤的是 Controller 中的事务，所以整个事务回滚。
<br>数据库中没有插⼊任何数据，也就是步骤 1 中的⽤户插⼊⽅法也回滚了。
<br><br><br>UserController 类中的代码不变，将添加用户和添加日志的方法修改为 REQUIRES_NEW 不支持当前事务，重新创建事务<br><img src="https://img-blog.csdnimg.cn/f33e1cd6421a4981b7c554499eb8bdbe.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>运行程序<br><img src="https://img-blog.csdnimg.cn/606b83fc65cc410a969f06c91290b2f3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br><img src="https://img-blog.csdnimg.cn/e29f5e1d339a4ea1879b319c685009b9.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>方法调用流程：Controller/add ——》 用户添加方法（userservice） ——》 日志添加方法（logservice）<br>当日志添加方法出现异常之后，嵌套事务的执行结果是：<br>
<br>用户添加不受影响，添加用户成功
<br>日志添加失败，因为发生异常回滚了事务
<br><img src="https://img-blog.csdnimg.cn/150d177bc6ec4c0680f7442fb9f3b88a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><br><br>先看嵌套事务<br><img src="https://img-blog.csdnimg.cn/478644d6d6504b4abf11bc83b251d2fc.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>在 LogService 中进行事务的回滚操作<br>最终执行的效果就是，User 表成功添加数据，而 Log 表中没有添加数据。Log 中的事务已经回滚，但是嵌套事务不会回滚嵌套之前的事务，也就是说 嵌套事务可以实现部分事务回滚<br>加入事务<br><img src="https://img-blog.csdnimg.cn/f53b5073fd604449a53fbb537cb0cf42.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>最终程序的执行结果：用户表和日志表都没有添加任何数据，说明整个事务都回滚了。也就是说 REQUIRED 如果回滚就是回滚所有事务，不能实现部分事务的回滚<br>
嵌套事务之所以能够实现部分事务的回滚，是因为事务中有一个保存点（相当于游戏存档），嵌套事务进入之后相当于新建一个保存点，而回滚时只回滚到当前保存点，因此之前的事务是不受影响的。
而 REQUIRED 是加入到当前事务中，并没有创建事务的保存点，因此出现了回滚就是整个事务的回滚
<br>总结二者区别：<br>
<br>整个事务如果全部执行成功，二者的结果是一样的
<br>如果事务执行到一半失败了，那么加入事务整个事务都会回滚；而嵌套事务会局部回滚，不会影响上一个方法中执行的结果
]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/spring/spring-事务（编程式事务、声明式事务@transactional、事务隔离级别、事务传播机制).html</link><guid isPermaLink="false">知识库/工作技能/spring/Spring 事务（编程式事务、声明式事务@Transactional、事务隔离级别、事务传播机制).md</guid><pubDate>Wed, 19 Jun 2024 16:00:17 GMT</pubDate><enclosure url="https://img-blog.csdnimg.cn/7b15deb5bae6435e84ce0ddd7b3d8ece.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://img-blog.csdnimg.cn/7b15deb5bae6435e84ce0ddd7b3d8ece.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring Cloud面试题（2020最新版）_sprigcloud 面试题-CSDN博客]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="为什么需要学习Spring Cloud" data-href="#为什么需要学习Spring Cloud" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#为什么需要学习Spring_Cloud" class="internal-link" target="_self" rel="noopener">为什么需要学习Spring Cloud</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring Cloud" data-href="#什么是Spring Cloud" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是Spring_Cloud" class="internal-link" target="_self" rel="noopener">什么是Spring Cloud</a>
<br><a data-tooltip-position="top" aria-label="设计目标与优缺点" data-href="#设计目标与优缺点" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#设计目标与优缺点" class="internal-link" target="_self" rel="noopener">设计目标与优缺点</a> <br><a data-tooltip-position="top" aria-label="设计目标" data-href="#设计目标" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#设计目标" class="internal-link" target="_self" rel="noopener">设计目标</a>
<br><a data-tooltip-position="top" aria-label="优缺点" data-href="#优缺点" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#优缺点" class="internal-link" target="_self" rel="noopener">优缺点</a> <br><a data-tooltip-position="top" aria-label="Spring Cloud发展前景" data-href="#Spring Cloud发展前景" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud发展前景" class="internal-link" target="_self" rel="noopener">Spring Cloud发展前景</a>
<br><a data-tooltip-position="top" aria-label="整体架构" data-href="#整体架构" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#整体架构" class="internal-link" target="_self" rel="noopener">整体架构</a>
<br><a data-tooltip-position="top" aria-label="主要项目" data-href="#主要项目" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#主要项目" class="internal-link" target="_self" rel="noopener">主要项目</a> <br><a data-tooltip-position="top" aria-label="Spring Cloud Config" data-href="#Spring Cloud Config" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Config" class="internal-link" target="_self" rel="noopener">Spring Cloud Config</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Netflix" data-href="#Spring Cloud Netflix" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Netflix" class="internal-link" target="_self" rel="noopener">Spring Cloud Netflix</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Bus" data-href="#Spring Cloud Bus" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Bus" class="internal-link" target="_self" rel="noopener">Spring Cloud Bus</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Consul" data-href="#Spring Cloud Consul" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Consul" class="internal-link" target="_self" rel="noopener">Spring Cloud Consul</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Security" data-href="#Spring Cloud Security" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Security" class="internal-link" target="_self" rel="noopener">Spring Cloud Security</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Sleuth" data-href="#Spring Cloud Sleuth" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Sleuth" class="internal-link" target="_self" rel="noopener">Spring Cloud Sleuth</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Stream" data-href="#Spring Cloud Stream" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Stream" class="internal-link" target="_self" rel="noopener">Spring Cloud Stream</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Task" data-href="#Spring Cloud Task" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Task" class="internal-link" target="_self" rel="noopener">Spring Cloud Task</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Zookeeper" data-href="#Spring Cloud Zookeeper" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Zookeeper" class="internal-link" target="_self" rel="noopener">Spring Cloud Zookeeper</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud Gateway" data-href="#Spring Cloud Gateway" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_Gateway" class="internal-link" target="_self" rel="noopener">Spring Cloud Gateway</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud OpenFeign" data-href="#Spring Cloud OpenFeign" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_OpenFeign" class="internal-link" target="_self" rel="noopener">Spring Cloud OpenFeign</a> <br><a data-tooltip-position="top" aria-label="Spring Cloud的版本关系" data-href="#Spring Cloud的版本关系" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud的版本关系" class="internal-link" target="_self" rel="noopener">Spring Cloud的版本关系</a> <br><a data-tooltip-position="top" aria-label="Spring Cloud和SpringBoot版本对应关系" data-href="#Spring Cloud和SpringBoot版本对应关系" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud和SpringBoot版本对应关系" class="internal-link" target="_self" rel="noopener">Spring Cloud和SpringBoot版本对应关系</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud和各子项目版本对应关系" data-href="#Spring Cloud和各子项目版本对应关系" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud和各子项目版本对应关系" class="internal-link" target="_self" rel="noopener">Spring Cloud和各子项目版本对应关系</a> <br><a data-tooltip-position="top" aria-label="SpringBoot和SpringCloud的区别？" data-href="#SpringBoot和SpringCloud的区别？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#SpringBoot和SpringCloud的区别？" class="internal-link" target="_self" rel="noopener">SpringBoot和SpringCloud的区别？</a>
<br><a data-tooltip-position="top" aria-label="使用 Spring Boot 开发分布式微服务时，我们面临以下问题" data-href="#使用 Spring Boot 开发分布式微服务时，我们面临以下问题" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#使用_Spring_Boot_开发分布式微服务时，我们面临以下问题" class="internal-link" target="_self" rel="noopener">使用 Spring Boot 开发分布式微服务时，我们面临以下问题</a>
<br><a data-tooltip-position="top" aria-label="服务注册和发现是什么意思？Spring Cloud 如何实现？" data-href="#服务注册和发现是什么意思？Spring Cloud 如何实现？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#服务注册和发现是什么意思？Spring_Cloud_如何实现？" class="internal-link" target="_self" rel="noopener">服务注册和发现是什么意思？Spring Cloud 如何实现？</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud 和dubbo区别?" data-href="#Spring Cloud 和dubbo区别?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud_和dubbo区别" class="internal-link" target="_self" rel="noopener">Spring Cloud 和dubbo区别?</a>
<br><a data-tooltip-position="top" aria-label="负载平衡的意义什么？" data-href="#负载平衡的意义什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#负载平衡的意义什么？" class="internal-link" target="_self" rel="noopener">负载平衡的意义什么？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Hystrix？它如何实现容错？" data-href="#什么是 Hystrix？它如何实现容错？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是_Hystrix？它如何实现容错？" class="internal-link" target="_self" rel="noopener">什么是 Hystrix？它如何实现容错？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Hystrix 断路器？我们需要它吗？" data-href="#什么是 Hystrix 断路器？我们需要它吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是_Hystrix_断路器？我们需要它吗？" class="internal-link" target="_self" rel="noopener">什么是 Hystrix 断路器？我们需要它吗？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Netflix Feign？它的优点是什么？" data-href="#什么是 Netflix Feign？它的优点是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是_Netflix_Feign？它的优点是什么？" class="internal-link" target="_self" rel="noopener">什么是 Netflix Feign？它的优点是什么？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Spring Cloud Bus？我们需要它吗？" data-href="#什么是 Spring Cloud Bus？我们需要它吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是_Spring_Cloud_Bus？我们需要它吗？" class="internal-link" target="_self" rel="noopener">什么是 Spring Cloud Bus？我们需要它吗？</a>
<br><a data-tooltip-position="top" aria-label="Spring Cloud断路器的作用" data-href="#Spring Cloud断路器的作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#Spring_Cloud断路器的作用" class="internal-link" target="_self" rel="noopener">Spring Cloud断路器的作用</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring Cloud Config?" data-href="#什么是Spring Cloud Config?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是Spring_Cloud_Config" class="internal-link" target="_self" rel="noopener">什么是Spring Cloud Config?</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring Cloud Gateway?" data-href="#什么是Spring Cloud Gateway?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html#什么是Spring_Cloud_Gateway" class="internal-link" target="_self" rel="noopener">什么是Spring Cloud Gateway?</a>
<br><br>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：<br>
<br>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；
<br>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；
<br>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。
<br>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。<br><br>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。<br><br><br>协调各个微服务，简化分布式系统开发。<br><br>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？<br>优点：<br>
<br>产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善
<br>组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；
<br>Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案
<br>服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率
<br>可以更精准的制定优化服务方案，提高系统的可维护性
<br>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发
<br>微服务可以是跨平台的，可以用任何一种语言开发
<br>适于互联网时代，产品迭代周期更短
<br>缺点：<br>
<br>微服务过多，治理成本高，不利于维护系统
<br>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大
<br>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。<br><br>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。<br><br><img alt="40bf74edd4755c5efc4b41f6b8e20ec5_MD5.png" src="https://pages-9hu.pages.dev/attachments/40bf74edd4755c5efc4b41f6b8e20ec5_md5.png" target="_self"><br><br>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架"Spring Boot化"的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。<br><br>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。<br><br>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。<br>
<br>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
<br>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
<br>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
<br>Feign：基于Ribbon和Hystrix的声明式服务调用组件；
<br>Zuul：API网关组件，对请求提供路由及过滤功能。
<br><br>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。<br><br>基于Hashicorp Consul的服务治理组件。<br><br>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。<br><br>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。<br><br>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。<br><br>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。<br><br>基于Apache Zookeeper的服务治理组件。<br><br>API网关组件，对请求提供路由及过滤功能。<br><br>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。<br><br>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。<br><br><br><br><br>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。 <br><br>SpringBoot专注于快速方便的开发单个个体微服务。<br>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，<br>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务<br>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系<br>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。<br><br>（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。<br>（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。<br>（3）冗余-分布式系统中的冗余问题。<br>（4）负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。<br>（5）性能-问题 由于各种运营开销导致的性能问题。<br>（6）部署复杂性-Devops 技能的要求。<br><br>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。<br><br>（1）服务调用方式 dubbo是RPC springcloud Rest Api<br>（2）注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper<br>（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。<br><br>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。<br><br>Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。<br>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。<br>思考以下微服务<br><img alt="f65e980518b8a66df861a8bb9d3fade5_MD5.jpg" src="https://pages-9hu.pages.dev/attachments/f65e980518b8a66df861a8bb9d3fade5_md5.jpg" target="_self"><br>假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。<br>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。<br>简化图如下所示<br><img alt="a218bd04f33d7d0155d0cd07baeb7c1e_MD5.png" src="https://pages-9hu.pages.dev/attachments/a218bd04f33d7d0155d0cd07baeb7c1e_md5.png" target="_self"><br>现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。<br><br>由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。<br><img alt="ade11b932065bf305d85b571d86d7892_MD5.png" src="https://pages-9hu.pages.dev/attachments/ade11b932065bf305d85b571d86d7892_md5.png" target="_self"><br>如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nMSJX6ml-1582105816943)(<a data-tooltip-position="top" aria-label="https://user-gold-cdn.xitu.io/2019/12/30/16f55fbfd4e33ae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)%5C%5D" rel="noopener" class="external-link is-unresolved" href="https://user-gold-cdn.xitu.io/2019/12/30/16f55fbfd4e33ae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)%5C%5D" target="_self">https://user-gold-cdn.xitu.io/2019/12/30/16f55fbfd4e33ae7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\]</a><br><br>Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。<br>Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。<br>在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST模板公开的 REST 服务。<br>但是我们必须编写大量代码才能执行以下步骤<br>（1）使用功能区进行负载平衡。<br>（2）获取服务实例，然后获取基本 URL。<br>（3）利用 REST 模板来使用服务。 前面的代码如下<br>`@Controller
public class ConsumerControllerClient {
@Autowired
private LoadBalancerClient loadBalancer;
public void getEmployee() throws RestClientException, IOException { ServiceInstance serviceInstance=loadBalancer.choose("employee-producer"); System.out.println(serviceInstance.getUri()); String baseUrl=serviceInstance.getUri().toString(); baseUrl=baseUrl+"/employee"; RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;String&gt; response=null; try{ response=restTemplate.exchange(baseUrl, HttpMethod.GET, getHeaders(),String.class); } catch (Exception ex) { System.out.println(ex); } System.out.println(response.getBody());
}` 复制<br>之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。<br><br>考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。<br>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。<br><img alt="07b13c428712c0aa1b978cb89b2630f7_MD5.png" src="https://pages-9hu.pages.dev/attachments/07b13c428712c0aa1b978cb89b2630f7_md5.png" target="_self"><br>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。<br>还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：// localhost：8080 / refresh。同样对于 Employee Producer2 http：//localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。<br><img alt="b7f6576090a71a952b5a7b9e4a07cefb_MD5.png" src="https://pages-9hu.pages.dev/attachments/b7f6576090a71a952b5a7b9e4a07cefb_md5.png" target="_self"><br>Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。<br><br>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）<br>断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务<br>半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭<br>关闭：当服务一直处于正常状态 能正常调用<br><br>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。<br>使用：<br>（1）添加pom依赖<br>（2）配置文件添加相关配置<br>（3）启动类添加注解@EnableConfigServer<br><br>Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。<br>使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-cloud面试题（2020最新版）_sprigcloud-面试题-csdn博客.html</link><guid isPermaLink="false">知识库/工作技能/面试资料/Spring Cloud面试题（2020最新版）_sprigcloud 面试题-CSDN博客.md</guid><pubDate>Wed, 19 Jun 2024 15:45:27 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/40bf74edd4755c5efc4b41f6b8e20ec5_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/40bf74edd4755c5efc4b41f6b8e20ec5_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring MVC面试题（2020最新版）]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="概述" data-href="#概述" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#概述" class="internal-link" target="_self" rel="noopener">概述</a> <br><a data-tooltip-position="top" aria-label="什么是Spring MVC？简单介绍下你对Spring MVC的理解？" data-href="#什么是Spring MVC？简单介绍下你对Spring MVC的理解？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#什么是Spring_MVC？简单介绍下你对Spring_MVC的理解？" class="internal-link" target="_self" rel="noopener">什么是Spring MVC？简单介绍下你对Spring MVC的理解？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC的优点" data-href="#Spring MVC的优点" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC的优点" class="internal-link" target="_self" rel="noopener">Spring MVC的优点</a> <br><a data-tooltip-position="top" aria-label="核心组件" data-href="#核心组件" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#核心组件" class="internal-link" target="_self" rel="noopener">核心组件</a> <br><a data-tooltip-position="top" aria-label="Spring MVC的主要组件？" data-href="#Spring MVC的主要组件？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC的主要组件？" class="internal-link" target="_self" rel="noopener">Spring MVC的主要组件？</a>
<br><a data-tooltip-position="top" aria-label="什么是DispatcherServlet" data-href="#什么是DispatcherServlet" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#什么是DispatcherServlet" class="internal-link" target="_self" rel="noopener">什么是DispatcherServlet</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring MVC框架的控制器？" data-href="#什么是Spring MVC框架的控制器？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#什么是Spring_MVC框架的控制器？" class="internal-link" target="_self" rel="noopener">什么是Spring MVC框架的控制器？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？" data-href="#Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？" class="internal-link" target="_self" rel="noopener">Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a> <br><a data-tooltip-position="top" aria-label="工作原理" data-href="#工作原理" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#工作原理" class="internal-link" target="_self" rel="noopener">工作原理</a> <br><a data-tooltip-position="top" aria-label="请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？" data-href="#请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#请描述Spring_MVC的工作流程？描述一下_DispatcherServlet_的工作流程？" class="internal-link" target="_self" rel="noopener">请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</a> <br><a data-tooltip-position="top" aria-label="MVC框架" data-href="#MVC框架" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#MVC框架" class="internal-link" target="_self" rel="noopener">MVC框架</a> <br><a data-tooltip-position="top" aria-label="MVC是什么？MVC设计模式的好处有哪些" data-href="#MVC是什么？MVC设计模式的好处有哪些" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#MVC是什么？MVC设计模式的好处有哪些" class="internal-link" target="_self" rel="noopener">MVC是什么？MVC设计模式的好处有哪些</a> <br><a data-tooltip-position="top" aria-label="常用注解" data-href="#常用注解" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#常用注解" class="internal-link" target="_self" rel="noopener">常用注解</a> <br><a data-tooltip-position="top" aria-label="注解原理是什么" data-href="#注解原理是什么" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#注解原理是什么" class="internal-link" target="_self" rel="noopener">注解原理是什么</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC常用的注解有哪些？" data-href="#Spring MVC常用的注解有哪些？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC常用的注解有哪些？" class="internal-link" target="_self" rel="noopener">Spring MVC常用的注解有哪些？</a>
<br><a data-tooltip-position="top" aria-label="SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？" data-href="#SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？" class="internal-link" target="_self" rel="noopener">SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</a>
<br><a data-tooltip-position="top" aria-label="@Controller注解的作用" data-href="#@Controller注解的作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#@Controller注解的作用" class="internal-link" target="_self" rel="noopener">@Controller注解的作用</a>
<br><a data-tooltip-position="top" aria-label="@RequestMapping注解的作用" data-href="#@RequestMapping注解的作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#@RequestMapping注解的作用" class="internal-link" target="_self" rel="noopener">@RequestMapping注解的作用</a>
<br><a data-tooltip-position="top" aria-label="@ResponseBody注解的作用" data-href="#@ResponseBody注解的作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#@ResponseBody注解的作用" class="internal-link" target="_self" rel="noopener">@ResponseBody注解的作用</a>
<br><a data-tooltip-position="top" aria-label="@PathVariable和@RequestParam的区别" data-href="#@PathVariable和@RequestParam的区别" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#@PathVariable和@RequestParam的区别" class="internal-link" target="_self" rel="noopener">@PathVariable和@RequestParam的区别</a> <br><a data-tooltip-position="top" aria-label="其他" data-href="#其他" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#其他" class="internal-link" target="_self" rel="noopener">其他</a> <br><a data-tooltip-position="top" aria-label="Spring MVC与Struts2区别" data-href="#Spring MVC与Struts2区别" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC与Struts2区别" class="internal-link" target="_self" rel="noopener">Spring MVC与Struts2区别</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC怎么样设定重定向和转发的？" data-href="#Spring MVC怎么样设定重定向和转发的？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC怎么样设定重定向和转发的？" class="internal-link" target="_self" rel="noopener">Spring MVC怎么样设定重定向和转发的？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC怎么和AJAX相互调用的？" data-href="#Spring MVC怎么和AJAX相互调用的？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC怎么和AJAX相互调用的？" class="internal-link" target="_self" rel="noopener">Spring MVC怎么和AJAX相互调用的？</a>
<br><a data-tooltip-position="top" aria-label="如何解决POST请求中文乱码问题，GET的又如何处理呢？" data-href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="internal-link" target="_self" rel="noopener">如何解决POST请求中文乱码问题，GET的又如何处理呢？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC的异常处理？" data-href="#Spring MVC的异常处理？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC的异常处理？" class="internal-link" target="_self" rel="noopener">Spring MVC的异常处理？</a>
<br><a data-tooltip-position="top" aria-label="如果在拦截请求中，我想拦截get方式提交的方法,怎么配置" data-href="#如果在拦截请求中，我想拦截get方式提交的方法,怎么配置" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#如果在拦截请求中，我想拦截get方式提交的方法,怎么配置" class="internal-link" target="_self" rel="noopener">如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</a>
<br><a data-tooltip-position="top" aria-label="怎样在方法里面得到Request,或者Session？" data-href="#怎样在方法里面得到Request,或者Session？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#怎样在方法里面得到Request,或者Session？" class="internal-link" target="_self" rel="noopener">怎样在方法里面得到Request,或者Session？</a>
<br><a data-tooltip-position="top" aria-label="如果想在拦截的方法里面得到从前台传入的参数,怎么得到？" data-href="#如果想在拦截的方法里面得到从前台传入的参数,怎么得到？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#如果想在拦截的方法里面得到从前台传入的参数,怎么得到？" class="internal-link" target="_self" rel="noopener">如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</a>
<br><a data-tooltip-position="top" aria-label="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？" data-href="#如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？" class="internal-link" target="_self" rel="noopener">如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC中函数的返回值是什么？" data-href="#Spring MVC中函数的返回值是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC中函数的返回值是什么？" class="internal-link" target="_self" rel="noopener">Spring MVC中函数的返回值是什么？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC用什么对象从后台向前台传递数据的？" data-href="#Spring MVC用什么对象从后台向前台传递数据的？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC用什么对象从后台向前台传递数据的？" class="internal-link" target="_self" rel="noopener">Spring MVC用什么对象从后台向前台传递数据的？</a>
<br><a data-tooltip-position="top" aria-label="怎么样把ModelMap里面的数据放入Session里面？" data-href="#怎么样把ModelMap里面的数据放入Session里面？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#怎么样把ModelMap里面的数据放入Session里面？" class="internal-link" target="_self" rel="noopener">怎么样把ModelMap里面的数据放入Session里面？</a>
<br><a data-tooltip-position="top" aria-label="Spring MVC里面拦截器是怎么写的" data-href="#Spring MVC里面拦截器是怎么写的" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#Spring_MVC里面拦截器是怎么写的" class="internal-link" target="_self" rel="noopener">Spring MVC里面拦截器是怎么写的</a>
<br><a data-tooltip-position="top" aria-label="介绍一下 WebApplicationContext" data-href="#介绍一下 WebApplicationContext" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html#介绍一下_WebApplicationContext" class="internal-link" target="_self" rel="noopener">介绍一下 WebApplicationContext</a> <br><br><br>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。<br><br>（1）可以支持各种视图技术,而不仅仅局限于JSP；<br>（2）与Spring框架集成（如IoC容器、AOP等）；<br>（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。<br>（4） 支持各种请求资源的映射策略。<br><br><br>（1）前端控制器 DispatcherServlet（不需要程序员开发）<br>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。<br>（2）处理器映射器HandlerMapping（不需要程序员开发）<br>作用：根据请求的URL来查找Handler<br>（3）处理器适配器HandlerAdapter<br>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。<br>（4）处理器Handler（需要程序员开发）<br>（5）视图解析器 ViewResolver（不需要程序员开发）<br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）<br>（6）视图View（需要程序员开发jsp）<br>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）<br><br>Spring的<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=MVC%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=MVC%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020" target="_self">MVC框架</a>是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。<br><br>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。<br><br>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。<br><br><br>（1）用户发送请求至前端控制器DispatcherServlet；<br>
（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>
（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>
（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>
（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>
（6）Handler执行完成返回ModelAndView；<br>
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>
（9）ViewResolver解析后返回具体View；<br>
（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>
（11）DispatcherServlet响应用户。<br><img alt="f42fc24d30e6f9d4568ab7923b434654_MD5.png" src="https://pages-9hu.pages.dev/attachments/f42fc24d30e6f9d4568ab7923b434654_md5.png" target="_self"><br><br><br>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。<br>mvc设计模式的好处<br>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。<br>2.有利于系统的并行开发，提升开发效率。<br><br><br>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。<br><br>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。<br><br>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。<br><br>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。<br>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：<br>
<br>在Spring MVC 的配置文件中定义MyController 的bean 对象。
<br>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。
<br><br>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。<br>value， method<br>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method： 指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces<br>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;<br>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers<br>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。<br><br>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；<br><br>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)<br>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。<br><br><br>相同点<br>都是基于mvc的表现层框架，都用于web项目的开发。<br>不同点<br>1.前端控制器不一样。Spring MVC的前端控制器是<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=servlet&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=servlet&amp;spm=1001.2101.3001.7020" target="_self">servlet</a>：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。<br>2.请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。<br>3.Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。<br>4.与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。<br><br>（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"<br>（2）重定向：在返回值前面加"redirect:"，譬如"redirect:<a data-tooltip-position="top" aria-label="http://www.baidu.com%22" rel="noopener" class="external-link is-unresolved" href="http://www.baidu.com%22" target="_self">http://www.baidu.com"</a><br><br>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：<br>（1）加入Jackson.jar<br>（2）在配置文件中配置json的映射<br>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。<br><br>（1）解决post请求乱码问题：<br>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；<br>`&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;
&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;` 复制<br>（2）get请求中文参数出现乱码解决方法有两个：<br>①修改tomcat配置文件添加编码与工程编码一致，如下：<br>`&lt;ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt;` 复制<br>②另外一种方法对参数进行重新编码：<br>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)<br>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。<br><br>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。<br><br>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。<br><br>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。<br><br>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。<br><br>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。<br><br>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。<br><br>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。<br><br>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。<br><br>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：<br> `&lt;mvc:interceptors&gt; &lt;bean id="myInterceptor" class="com.zwp.action.MyHandlerInterceptor"&gt;&lt;/bean&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/modelMap.do" /&gt; &lt;bean class="com.zwp.action.MyHandlerInterceptorAdapter" /&gt; &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;` 复制<br><br>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-mvc面试题（2020最新版）.html</link><guid isPermaLink="false">知识库/工作技能/面试资料/Spring MVC面试题（2020最新版）.md</guid><pubDate>Wed, 19 Jun 2024 15:43:34 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/f42fc24d30e6f9d4568ab7923b434654_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/f42fc24d30e6f9d4568ab7923b434654_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring面试题（2020最新版）]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="Spring概述" data-href="#Spring概述" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring概述" class="internal-link" target="_self" rel="noopener">Spring概述</a> <br><a data-tooltip-position="top" aria-label="什么是spring?" data-href="#什么是spring?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是spring" class="internal-link" target="_self" rel="noopener">什么是spring?</a>
<br><a data-tooltip-position="top" aria-label="Spring框架的设计目标，设计理念，和核心是什么" data-href="#Spring框架的设计目标，设计理念，和核心是什么" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring框架的设计目标，设计理念，和核心是什么" class="internal-link" target="_self" rel="noopener">Spring框架的设计目标，设计理念，和核心是什么</a>
<br><a data-tooltip-position="top" aria-label="Spring的优缺点是什么？" data-href="#Spring的优缺点是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring的优缺点是什么？" class="internal-link" target="_self" rel="noopener">Spring的优缺点是什么？</a>
<br><a data-tooltip-position="top" aria-label="Spring有哪些应用场景" data-href="#Spring有哪些应用场景" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring有哪些应用场景" class="internal-link" target="_self" rel="noopener">Spring有哪些应用场景</a>
<br><a data-tooltip-position="top" aria-label="Spring由哪些模块组成？" data-href="#Spring由哪些模块组成？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring由哪些模块组成？" class="internal-link" target="_self" rel="noopener">Spring由哪些模块组成？</a>
<br><a data-tooltip-position="top" aria-label="Spring 框架中都用到了哪些设计模式？" data-href="#Spring 框架中都用到了哪些设计模式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_框架中都用到了哪些设计模式？" class="internal-link" target="_self" rel="noopener">Spring 框架中都用到了哪些设计模式？</a>
<br><a data-tooltip-position="top" aria-label="详细讲解一下核心容器（spring context应用上下文) 模块" data-href="#详细讲解一下核心容器（spring context应用上下文) 模块" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#详细讲解一下核心容器（spring_context应用上下文)_模块" class="internal-link" target="_self" rel="noopener">详细讲解一下核心容器（spring context应用上下文) 模块</a>
<br><a data-tooltip-position="top" aria-label="Spring框架中有哪些不同类型的事件" data-href="#Spring框架中有哪些不同类型的事件" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring框架中有哪些不同类型的事件" class="internal-link" target="_self" rel="noopener">Spring框架中有哪些不同类型的事件</a>
<br><a data-tooltip-position="top" aria-label="Spring 应用程序有哪些不同组件？" data-href="#Spring 应用程序有哪些不同组件？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_应用程序有哪些不同组件？" class="internal-link" target="_self" rel="noopener">Spring 应用程序有哪些不同组件？</a>
<br><a data-tooltip-position="top" aria-label="使用 Spring 有哪些方式？" data-href="#使用 Spring 有哪些方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#使用_Spring_有哪些方式？" class="internal-link" target="_self" rel="noopener">使用 Spring 有哪些方式？</a> <br><a data-tooltip-position="top" aria-label="Spring控制反转(IOC)（13）" data-href="#Spring控制反转(IOC)（13）" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring控制反转(IOC)（13）" class="internal-link" target="_self" rel="noopener">Spring控制反转(IOC)（13）</a> <br><a data-tooltip-position="top" aria-label="什么是Spring IOC 容器？" data-href="#什么是Spring IOC 容器？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是Spring_IOC_容器？" class="internal-link" target="_self" rel="noopener">什么是Spring IOC 容器？</a>
<br><a data-tooltip-position="top" aria-label="控制反转(IoC)有什么作用" data-href="#控制反转(IoC)有什么作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#控制反转(IoC)有什么作用" class="internal-link" target="_self" rel="noopener">控制反转(IoC)有什么作用</a>
<br><a data-tooltip-position="top" aria-label="IOC的优点是什么？" data-href="#IOC的优点是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#IOC的优点是什么？" class="internal-link" target="_self" rel="noopener">IOC的优点是什么？</a>
<br><a data-tooltip-position="top" aria-label="Spring IoC 的实现机制" data-href="#Spring IoC 的实现机制" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_IoC_的实现机制" class="internal-link" target="_self" rel="noopener">Spring IoC 的实现机制</a>
<br><a data-tooltip-position="top" aria-label="Spring 的 IoC支持哪些功能" data-href="#Spring 的 IoC支持哪些功能" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_的_IoC支持哪些功能" class="internal-link" target="_self" rel="noopener">Spring 的 IoC支持哪些功能</a>
<br><a data-tooltip-position="top" aria-label="BeanFactory 和 ApplicationContext有什么区别？" data-href="#BeanFactory 和 ApplicationContext有什么区别？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#BeanFactory_和_ApplicationContext有什么区别？" class="internal-link" target="_self" rel="noopener">BeanFactory 和 ApplicationContext有什么区别？</a>
<br><a data-tooltip-position="top" aria-label="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解" data-href="#Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="internal-link" target="_self" rel="noopener">Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</a>
<br><a data-tooltip-position="top" aria-label="ApplicationContext通常的实现是什么？" data-href="#ApplicationContext通常的实现是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#ApplicationContext通常的实现是什么？" class="internal-link" target="_self" rel="noopener">ApplicationContext通常的实现是什么？</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring的依赖注入？" data-href="#什么是Spring的依赖注入？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是Spring的依赖注入？" class="internal-link" target="_self" rel="noopener">什么是Spring的依赖注入？</a>
<br><a data-tooltip-position="top" aria-label="依赖注入的基本原则" data-href="#依赖注入的基本原则" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#依赖注入的基本原则" class="internal-link" target="_self" rel="noopener">依赖注入的基本原则</a>
<br><a data-tooltip-position="top" aria-label="依赖注入有什么优势" data-href="#依赖注入有什么优势" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#依赖注入有什么优势" class="internal-link" target="_self" rel="noopener">依赖注入有什么优势</a>
<br><a data-tooltip-position="top" aria-label="有哪些不同类型的依赖注入实现方式？" data-href="#有哪些不同类型的依赖注入实现方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#有哪些不同类型的依赖注入实现方式？" class="internal-link" target="_self" rel="noopener">有哪些不同类型的依赖注入实现方式？</a>
<br><a data-tooltip-position="top" aria-label="构造器依赖注入和 Setter方法注入的区别" data-href="#构造器依赖注入和 Setter方法注入的区别" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#构造器依赖注入和_Setter方法注入的区别" class="internal-link" target="_self" rel="noopener">构造器依赖注入和 Setter方法注入的区别</a> <br><a data-tooltip-position="top" aria-label="Spring Beans（19）" data-href="#Spring Beans（19）" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_Beans（19）" class="internal-link" target="_self" rel="noopener">Spring Beans（19）</a> <br><a data-tooltip-position="top" aria-label="什么是Spring beans？" data-href="#什么是Spring beans？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是Spring_beans？" class="internal-link" target="_self" rel="noopener">什么是Spring beans？</a>
<br><a data-tooltip-position="top" aria-label="一个 Spring Bean 定义 包含什么？" data-href="#一个 Spring Bean 定义 包含什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#一个_Spring_Bean_定义_包含什么？" class="internal-link" target="_self" rel="noopener">一个 Spring Bean 定义 包含什么？</a>
<br><a data-tooltip-position="top" aria-label="如何给Spring 容器提供配置元数据？Spring有几种配置方式" data-href="#如何给Spring 容器提供配置元数据？Spring有几种配置方式" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#如何给Spring_容器提供配置元数据？Spring有几种配置方式" class="internal-link" target="_self" rel="noopener">如何给Spring 容器提供配置元数据？Spring有几种配置方式</a>
<br><a data-tooltip-position="top" aria-label="Spring配置文件包含了哪些信息" data-href="#Spring配置文件包含了哪些信息" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring配置文件包含了哪些信息" class="internal-link" target="_self" rel="noopener">Spring配置文件包含了哪些信息</a>
<br><a data-tooltip-position="top" aria-label="Spring基于xml注入bean的几种方式" data-href="#Spring基于xml注入bean的几种方式" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring基于xml注入bean的几种方式" class="internal-link" target="_self" rel="noopener">Spring基于xml注入bean的几种方式</a>
<br><a data-tooltip-position="top" aria-label="你怎样定义类的作用域？" data-href="#你怎样定义类的作用域？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#你怎样定义类的作用域？" class="internal-link" target="_self" rel="noopener">你怎样定义类的作用域？</a>
<br><a data-tooltip-position="top" aria-label="解释Spring支持的几种bean的作用域" data-href="#解释Spring支持的几种bean的作用域" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释Spring支持的几种bean的作用域" class="internal-link" target="_self" rel="noopener">解释Spring支持的几种bean的作用域</a>
<br><a data-tooltip-position="top" aria-label="Spring框架中的单例bean是线程安全的吗？" data-href="#Spring框架中的单例bean是线程安全的吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring框架中的单例bean是线程安全的吗？" class="internal-link" target="_self" rel="noopener">Spring框架中的单例bean是线程安全的吗？</a>
<br><a data-tooltip-position="top" aria-label="Spring如何处理线程并发问题？" data-href="#Spring如何处理线程并发问题？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring如何处理线程并发问题？" class="internal-link" target="_self" rel="noopener">Spring如何处理线程并发问题？</a>
<br><a data-tooltip-position="top" aria-label="解释Spring框架中bean的生命周期" data-href="#解释Spring框架中bean的生命周期" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释Spring框架中bean的生命周期" class="internal-link" target="_self" rel="noopener">解释Spring框架中bean的生命周期</a>
<br><a data-tooltip-position="top" aria-label="哪些是重要的bean生命周期方法？ 你能重载它们吗？" data-href="#哪些是重要的bean生命周期方法？ 你能重载它们吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#哪些是重要的bean生命周期方法？_你能重载它们吗？" class="internal-link" target="_self" rel="noopener">哪些是重要的bean生命周期方法？ 你能重载它们吗？</a>
<br><a data-tooltip-position="top" aria-label="什么是Spring的内部bean？什么是Spring inner beans？" data-href="#什么是Spring的内部bean？什么是Spring inner beans？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是Spring的内部bean？什么是Spring_inner_beans？" class="internal-link" target="_self" rel="noopener">什么是Spring的内部bean？什么是Spring inner beans？</a>
<br><a data-tooltip-position="top" aria-label="在 Spring中如何注入一个java集合？" data-href="#在 Spring中如何注入一个java集合？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#在_Spring中如何注入一个java集合？" class="internal-link" target="_self" rel="noopener">在 Spring中如何注入一个java集合？</a>
<br><a data-tooltip-position="top" aria-label="什么是bean装配？" data-href="#什么是bean装配？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是bean装配？" class="internal-link" target="_self" rel="noopener">什么是bean装配？</a>
<br><a data-tooltip-position="top" aria-label="什么是bean的自动装配？" data-href="#什么是bean的自动装配？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是bean的自动装配？" class="internal-link" target="_self" rel="noopener">什么是bean的自动装配？</a>
<br><a data-tooltip-position="top" aria-label="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？" data-href="#解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释不同方式的自动装配，spring_自动装配_bean_有哪些方式？" class="internal-link" target="_self" rel="noopener">解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</a>
<br><a data-tooltip-position="top" aria-label="使用@Autowired注解自动装配的过程是怎样的？" data-href="#使用@Autowired注解自动装配的过程是怎样的？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#使用@Autowired注解自动装配的过程是怎样的？" class="internal-link" target="_self" rel="noopener">使用@Autowired注解自动装配的过程是怎样的？</a>
<br><a data-tooltip-position="top" aria-label="自动装配有哪些局限性？" data-href="#自动装配有哪些局限性？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#自动装配有哪些局限性？" class="internal-link" target="_self" rel="noopener">自动装配有哪些局限性？</a>
<br><a data-tooltip-position="top" aria-label="你可以在Spring中注入一个null 和一个空字符串吗？" data-href="#你可以在Spring中注入一个null 和一个空字符串吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#你可以在Spring中注入一个null_和一个空字符串吗？" class="internal-link" target="_self" rel="noopener">你可以在Spring中注入一个null 和一个空字符串吗？</a> <br><a data-tooltip-position="top" aria-label="Spring注解（8）" data-href="#Spring注解（8）" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring注解（8）" class="internal-link" target="_self" rel="noopener">Spring注解（8）</a> <br><a data-tooltip-position="top" aria-label="什么是基于Java的Spring注解配置? 给一些注解的例子" data-href="#什么是基于Java的Spring注解配置? 给一些注解的例子" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是基于Java的Spring注解配置?_给一些注解的例子" class="internal-link" target="_self" rel="noopener">什么是基于Java的Spring注解配置? 给一些注解的例子</a>
<br><a data-tooltip-position="top" aria-label="怎样开启注解装配？" data-href="#怎样开启注解装配？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#怎样开启注解装配？" class="internal-link" target="_self" rel="noopener">怎样开启注解装配？</a>
<br><a data-tooltip-position="top" aria-label="@Component, @Controller, @Repository, @Service 有何区别？" data-href="#@Component, @Controller, @Repository, @Service 有何区别？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@Component,_@Controller,_@Repository,_@Service_有何区别？" class="internal-link" target="_self" rel="noopener">@Component, @Controller, @Repository, @Service 有何区别？</a>
<br><a data-tooltip-position="top" aria-label="@Required 注解有什么作用" data-href="#@Required 注解有什么作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@Required_注解有什么作用" class="internal-link" target="_self" rel="noopener">@Required 注解有什么作用</a>
<br><a data-tooltip-position="top" aria-label="@Autowired 注解有什么作用" data-href="#@Autowired 注解有什么作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@Autowired_注解有什么作用" class="internal-link" target="_self" rel="noopener">@Autowired 注解有什么作用</a>
<br><a data-tooltip-position="top" aria-label="@Autowired和@Resource之间的区别" data-href="#@Autowired和@Resource之间的区别" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@Autowired和@Resource之间的区别" class="internal-link" target="_self" rel="noopener">@Autowired和@Resource之间的区别</a>
<br><a data-tooltip-position="top" aria-label="@Qualifier 注解有什么作用" data-href="#@Qualifier 注解有什么作用" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@Qualifier_注解有什么作用" class="internal-link" target="_self" rel="noopener">@Qualifier 注解有什么作用</a>
<br><a data-tooltip-position="top" aria-label="@RequestMapping 注解有什么用？" data-href="#@RequestMapping 注解有什么用？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#@RequestMapping_注解有什么用？" class="internal-link" target="_self" rel="noopener">@RequestMapping 注解有什么用？</a> <br><a data-tooltip-position="top" aria-label="Spring数据访问（14）" data-href="#Spring数据访问（14）" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring数据访问（14）" class="internal-link" target="_self" rel="noopener">Spring数据访问（14）</a> <br><a data-tooltip-position="top" aria-label="解释对象/关系映射集成模块" data-href="#解释对象/关系映射集成模块" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释对象/关系映射集成模块" class="internal-link" target="_self" rel="noopener">解释对象/关系映射集成模块</a>
<br><a data-tooltip-position="top" aria-label="在Spring框架中如何更有效地使用JDBC？" data-href="#在Spring框架中如何更有效地使用JDBC？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#在Spring框架中如何更有效地使用JDBC？" class="internal-link" target="_self" rel="noopener">在Spring框架中如何更有效地使用JDBC？</a>
<br><a data-tooltip-position="top" aria-label="解释JDBC抽象和DAO模块" data-href="#解释JDBC抽象和DAO模块" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释JDBC抽象和DAO模块" class="internal-link" target="_self" rel="noopener">解释JDBC抽象和DAO模块</a>
<br><a data-tooltip-position="top" aria-label="spring DAO 有什么用？" data-href="#spring DAO 有什么用？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#spring_DAO_有什么用？" class="internal-link" target="_self" rel="noopener">spring DAO 有什么用？</a>
<br><a data-tooltip-position="top" aria-label="spring JDBC API 中存在哪些类？" data-href="#spring JDBC API 中存在哪些类？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#spring_JDBC_API_中存在哪些类？" class="internal-link" target="_self" rel="noopener">spring JDBC API 中存在哪些类？</a>
<br><a data-tooltip-position="top" aria-label="JdbcTemplate是什么" data-href="#JdbcTemplate是什么" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#JdbcTemplate是什么" class="internal-link" target="_self" rel="noopener">JdbcTemplate是什么</a>
<br><a data-tooltip-position="top" aria-label="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？" data-href="#使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#使用Spring通过什么方式访问Hibernate？使用_Spring_访问_Hibernate_的方法有哪些？" class="internal-link" target="_self" rel="noopener">使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</a>
<br><a data-tooltip-position="top" aria-label="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" data-href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="internal-link" target="_self" rel="noopener">如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</a>
<br><a data-tooltip-position="top" aria-label="Spring支持的事务管理类型， spring 事务实现方式有哪些？" data-href="#Spring支持的事务管理类型， spring 事务实现方式有哪些？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring支持的事务管理类型，_spring_事务实现方式有哪些？" class="internal-link" target="_self" rel="noopener">Spring支持的事务管理类型， spring 事务实现方式有哪些？</a>
<br><a data-tooltip-position="top" aria-label="Spring事务的实现方式和实现原理" data-href="#Spring事务的实现方式和实现原理" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring事务的实现方式和实现原理" class="internal-link" target="_self" rel="noopener">Spring事务的实现方式和实现原理</a>
<br><a data-tooltip-position="top" aria-label="说一下Spring的事务传播行为" data-href="#说一下Spring的事务传播行为" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#说一下Spring的事务传播行为" class="internal-link" target="_self" rel="noopener">说一下Spring的事务传播行为</a>
<br><a data-tooltip-position="top" aria-label="说一下 spring 的事务隔离？" data-href="#说一下 spring 的事务隔离？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#说一下_spring_的事务隔离？" class="internal-link" target="_self" rel="noopener">说一下 spring 的事务隔离？</a>
<br><a data-tooltip-position="top" aria-label="Spring框架的事务管理有哪些优点？" data-href="#Spring框架的事务管理有哪些优点？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring框架的事务管理有哪些优点？" class="internal-link" target="_self" rel="noopener">Spring框架的事务管理有哪些优点？</a>
<br><a data-tooltip-position="top" aria-label="你更倾向用那种事务管理类型？" data-href="#你更倾向用那种事务管理类型？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#你更倾向用那种事务管理类型？" class="internal-link" target="_self" rel="noopener">你更倾向用那种事务管理类型？</a> <br><a data-tooltip-position="top" aria-label="Spring面向切面编程(AOP)（13）" data-href="#Spring面向切面编程(AOP)（13）" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring面向切面编程(AOP)（13）" class="internal-link" target="_self" rel="noopener">Spring面向切面编程(AOP)（13）</a> <br><a data-tooltip-position="top" aria-label="什么是AOP" data-href="#什么是AOP" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是AOP" class="internal-link" target="_self" rel="noopener">什么是AOP</a>
<br><a data-tooltip-position="top" aria-label="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？" data-href="#Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring_AOP_and_AspectJ_AOP_有什么区别？AOP_有哪些实现方式？" class="internal-link" target="_self" rel="noopener">Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</a>
<br><a data-tooltip-position="top" aria-label="JDK动态代理和CGLIB动态代理的区别" data-href="#JDK动态代理和CGLIB动态代理的区别" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#JDK动态代理和CGLIB动态代理的区别" class="internal-link" target="_self" rel="noopener">JDK动态代理和CGLIB动态代理的区别</a>
<br><a data-tooltip-position="top" aria-label="如何理解 Spring 中的代理？" data-href="#如何理解 Spring 中的代理？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#如何理解_Spring_中的代理？" class="internal-link" target="_self" rel="noopener">如何理解 Spring 中的代理？</a>
<br><a data-tooltip-position="top" aria-label="解释一下Spring AOP里面的几个名词" data-href="#解释一下Spring AOP里面的几个名词" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释一下Spring_AOP里面的几个名词" class="internal-link" target="_self" rel="noopener">解释一下Spring AOP里面的几个名词</a>
<br><a data-tooltip-position="top" aria-label="Spring在运行时通知对象" data-href="#Spring在运行时通知对象" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring在运行时通知对象" class="internal-link" target="_self" rel="noopener">Spring在运行时通知对象</a>
<br><a data-tooltip-position="top" aria-label="Spring只支持方法级别的连接点" data-href="#Spring只支持方法级别的连接点" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring只支持方法级别的连接点" class="internal-link" target="_self" rel="noopener">Spring只支持方法级别的连接点</a>
<br><a data-tooltip-position="top" aria-label="在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处" data-href="#在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#在Spring_AOP_中，关注点和横切关注的区别是什么？在_spring_aop_中_concern_和_cross-cutting_concern_的不同之处" class="internal-link" target="_self" rel="noopener">在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</a>
<br><a data-tooltip-position="top" aria-label="Spring通知有哪些类型？" data-href="#Spring通知有哪些类型？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#Spring通知有哪些类型？" class="internal-link" target="_self" rel="noopener">Spring通知有哪些类型？</a>
<br><a data-tooltip-position="top" aria-label="什么是切面 Aspect？" data-href="#什么是切面 Aspect？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#什么是切面_Aspect？" class="internal-link" target="_self" rel="noopener">什么是切面 Aspect？</a>
<br><a data-tooltip-position="top" aria-label="解释基于XML Schema方式的切面实现" data-href="#解释基于XML Schema方式的切面实现" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释基于XML_Schema方式的切面实现" class="internal-link" target="_self" rel="noopener">解释基于XML Schema方式的切面实现</a>
<br><a data-tooltip-position="top" aria-label="解释基于注解的切面实现" data-href="#解释基于注解的切面实现" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#解释基于注解的切面实现" class="internal-link" target="_self" rel="noopener">解释基于注解的切面实现</a>
<br><a data-tooltip-position="top" aria-label="有几种不同类型的自动代理？" data-href="#有几种不同类型的自动代理？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html#有几种不同类型的自动代理？" class="internal-link" target="_self" rel="noopener">有几种不同类型的自动代理？</a> <br><br><br>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。<br>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。<br>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）。<br>为了降低Java开发的复杂性，Spring采取了以下4种关键策略<br>
<br>基于POJO的轻量级和最小侵入性编程；
<br>通过依赖注入和面向接口实现松耦合；
<br>基于切面和惯例进行声明式编程；
<br>通过切面和模板减少样板式代码。
<br><br>Spring设计目标：Spring为开发者提供一个一站式轻量级应用开发平台；<br>Spring设计理念：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；<br>Spring框架的核心：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。<br>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。<br><br>优点<br>
<br>
方便解耦，简化开发
Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。 <br>
AOP编程的支持
Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 <br>
声明式事务的支持
只需要通过配置就可以完成对事务的管理，而无需手动编程。 <br>
方便程序的测试
Spring对Junit4支持，可以通过注解方便的测试Spring程序。 <br>
方便集成各种优秀框架
Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。 <br>
降低JavaEE API的使用难度
Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。 <br>缺点<br>
<br>Spring明明一个很轻量级的框架，却给人感觉大而全
<br>Spring依赖反射，反射影响性能
<br>使用门槛升高，入门Spring需要较长时间
<br><br>应用场景：JavaEE企业应用开发，包括SSH、SSM等<br>Spring价值：<br>
<br>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；
<br>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；
<br>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；
<br><br>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图：<br><img alt="dcdd1e3203ed6a0b4dedaf1534cc395f_MD5.png" src="https://pages-9hu.pages.dev/attachments/dcdd1e3203ed6a0b4dedaf1534cc395f_md5.png" target="_self"><br>
<br>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。
<br>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。
<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。
<br>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。
<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。
<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。
<br>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。
<br><br>
<br>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
<br>单例模式：Bean默认为单例模式。
<br>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
<br>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。
<br>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。
<br><br>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。<br>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。<br><br>Spring 提供了以下5种标准的事件：<br>
<br>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。
<br>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。
<br>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。
<br>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。
<br>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。
<br><br>Spring 应用一般有以下组件：<br>
<br>接口 - 定义功能。
<br>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。
<br>Bean 配置文件 - 包含类的信息以及如何配置它们。
<br>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。
<br>用户程序 - 它使用接口。
<br><br>使用 Spring 有以下方式：<br>
<br>作为一个成熟的 Spring Web 应用程序。
<br>作为第三方 Web 框架，使用 Spring Frameworks 中间层。
<br>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。
<br>用于远程使用。
<br><br><br>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。<br>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。<br><br>
<br>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的
<br>解耦，由容器去维护具体的对象
<br>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的
<br><br>
<br>IOC 或 依赖注入把应用的代码量降到最低。
<br>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。
<br>最小的代价和最小的侵入性使松散耦合得以实现。
<br>IOC容器支持加载服务时的饿汉式初始化和懒加载。
<br><br>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：<br>interface Fruit { public abstract void eat(); } class Apple implements Fruit { public void eat(){ System.out.println("Apple"); }
} class Orange implements Fruit { public void eat(){ System.out.println("Orange"); }
} class Factory { public static Fruit getInstance(String ClassName) { Fruit f=null; try { f=(Fruit)Class.forName(ClassName).newInstance(); } catch (Exception e) { e.printStackTrace(); } return f; }
} class Client { public static void main(String[] a) { Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple"); if(f!=null){ f.eat(); } }
} 复制<br><br>Spring 的 IoC 设计支持以下功能：<br>
<br>依赖注入
<br>依赖检查
<br>自动装配
<br>支持集合
<br>指定初始化方法和销毁方法
<br>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）
<br>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。<br>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。<br><br>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。<br>依赖关系<br>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<br>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<br>
<br>继承MessageSource，因此支持国际化。
<br>统一的资源文件访问方式。
<br>提供在监听器中注册bean的事件。
<br>同时加载多个配置文件。
<br>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。
<br>加载方式<br>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。<br>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。<br>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。<br>创建方式<br>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。<br>注册方式<br>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。<br><br>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。<br>
<br>BeanFactory
<br>ApplicationContext
<br>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。<br>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。<br>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。<br>BeanFactory和ApplicationContext的关系<br>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。<br><img alt="29447fff0c8758146a97d52d40035734_MD5.png" src="https://pages-9hu.pages.dev/attachments/29447fff0c8758146a97d52d40035734_md5.png" target="_self"><br>有点复杂？ 先不要慌，我来解释一下。<br>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。<br>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。<br>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！<br>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。<br>小结<br>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：<br>
<br>加载配置文件，解析成 BeanDefinition 放在 Map 里。
<br>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。
<br>上面就是 Spring 低级容器（BeanFactory）的 IoC。<br>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。<br><br>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。<br>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。<br>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。<br><br>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找<br>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。<br><br>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。<br><br>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：<br>
<br>查找定位操作与应用代码完全无关。
<br>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。
<br>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。
<br><br>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。<br>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。<br><br><br>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。<br><br><br>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。<br><br>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。<br><br>这里有三种重要的方法给Spring 容器提供配置元数据。<br>
<br>XML配置文件。
<br>基于注解的配置。
<br>基于java的配置。
<br><br>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。<br><br>
<br>Set方法注入；
<br>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；
<br>静态工厂注入；
<br>实例工厂；
<br><br>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。<br><br>Spring框架支持以下五种bean的作用域：<br>
<br>singleton : bean在每个Spring ioc 容器中只有一个实例。
<br>prototype：一个bean的定义可以有多个实例。
<br>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
<br>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
<br>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
<br>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。<br><br>不是，Spring框架中的单例bean不是线程安全的。<br>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。<br>
<br>有状态就是有数据存储功能。
<br>无状态就是不会保存数据。
<br><br>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。<br>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br><br>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。<br><img alt="8656d73b49f9492bf13c52aec6cc95ac_MD5.png" src="https://pages-9hu.pages.dev/attachments/8656d73b49f9492bf13c52aec6cc95ac_md5.png" target="_self"><br>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。<br>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。<br>我们对上图进行详细描述：<br>Spring对bean进行实例化；<br>Spring将值和bean的引用注入到bean对应的属性中；<br>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；<br>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；<br>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；<br>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；<br>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；<br>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；<br>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；<br>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。<br>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。<br><br>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。<br>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。<br><br>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。<br><br>Spring提供以下几种集合的配置元素：<br>类型用于注入一列值，允许有相同的值。<br>类型用于注入一组值，不允许有相同的值。<br>类型用于注入一组键值对，键和值都可以为任意类型。<br>类型用于注入一组键值对，键和值都只能为String类型。<br><br>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。<br><br>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。<br><br>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。<br>在Spring框架xml配置中共有5种自动装配：<br>
<br>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。
<br>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。
<br>byType：通过参数的数据类型进行自动装配。
<br>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。
<br>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。
<br><br>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。<br>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：<br>
<br>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；
<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找；
<br>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。
<br><br>自动装配的局限性是：<br>重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。<br>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。<br>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。<br><br>可以。<br><br><br>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。<br>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。<br>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。<br>`@Configuration
public class StudentConfig { @Bean public StudentBean myStudent() { return new StudentBean(); }
}` 复制<br><br>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 &lt;context:annotation-config/&gt;元素。<br><br>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。<br>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。<br>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。<br>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。<br><br>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：<br>`public class Employee { private String name; @Required public void setName(String name){ this.name=name; } public string getName(){ return name; }
}` 复制<br><br>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。<br>`public class Employee { private String name; @Autowired public void setName(String name) { this.name=name; } public string getName(){ return name; }
}` 复制<br><br>@Autowired可用于：构造函数、成员变量、Setter方法<br>@Autowired和@Resource之间的区别<br>
<br>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。
<br>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。
<br><br>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。<br><br>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<br>
<br>类级别：映射请求的 URL
<br>方法级别：映射 URL 以及 HTTP 请求方法
<br><br><br>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。<br><br>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate<br><br>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。<br><br>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。<br><br>JdbcTemplate<br>SimpleJdbcTemplate<br>NamedParameterJdbcTemplate<br>SimpleJdbcInsert<br>SimpleJdbcCall<br><br>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。<br><br>在Spring中有两种方式访问Hibernate：<br>
<br>使用 Hibernate 模板和回调进行控制反转
<br>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点
<br><br>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br>
<br>配置the Hibernate SessionFactory
<br>继承HibernateDaoSupport实现一个DAO
<br>在AOP支持的事务中装配
<br><br>Spring支持两种类型的事务管理：<br>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。<br>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。<br><br>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。<br><br>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。<br>
① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。
<br><br>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：<br>
<br>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；
<br>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；
<br>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；
<br>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；
<br>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。
<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br><br>
<br>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。
<br>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API
<br>支持声明式事务管理。
<br>和Spring各种数据访问抽象层很好得集成。
<br><br>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。<br><br><br>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。<br>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。<br><br>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<br>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。<br>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<br><br>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：<br>
<br>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。
<br>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。
<br>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。<br>
InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。
<br><br>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br>Advice + Target Object = Proxy<br><br>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。<br>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。<br>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。<br>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。<br>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。<br>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：<br>
<br>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。
<br>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。
<br>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。
<br><br>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。<br>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。<br><br>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。<br><br>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。<br><br>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。<br>Spring切面可以应用5种类型的通知：<br>
<br>前置通知（Before）：在目标方法被调用之前调用通知功能；
<br>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
<br>返回通知（After-returning ）：在目标方法成功执行之后调用通知；
<br>异常通知（After-throwing）：在目标方法抛出异常后调用通知；
<br>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。
<br>
同一个aspect，不同advice的执行顺序：
①没有异常情况下的执行顺序：
around before advice<br>
before advice<br>
target method 执行<br>
around after advice<br>
after advice<br>
afterReturning
②有异常情况下的执行顺序：
around before advice<br>
before advice<br>
target method 执行<br>
around after advice<br>
after advice<br>
afterThrowing:异常发生<br>
java.lang.RuntimeException: 异常发生
<br><br>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>
AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>
<br>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上
<br>如何在 advice 中编写切面代码.
<br>可以简单地认为, 使用 @Aspect 注解的类就是切面.<br><img alt="1773346cb98a9e6f6f4de32d1f169972_MD5.png" src="https://pages-9hu.pages.dev/attachments/1773346cb98a9e6f6f4de32d1f169972_md5.png" target="_self"><br><br>在这种情况下，切面由常规类以及基于XML的配置实现。<br><br>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。<br><br>BeanNameAutoProxyCreator<br>DefaultAdvisorAutoProxyCreator<br>Metadata autoproxying]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring面试题（2020最新版）.html</link><guid isPermaLink="false">知识库/工作技能/面试资料/Spring面试题（2020最新版）.md</guid><pubDate>Wed, 19 Jun 2024 15:41:37 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/dcdd1e3203ed6a0b4dedaf1534cc395f_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/dcdd1e3203ed6a0b4dedaf1534cc395f_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring Boot面试题（2020最新版）]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="概述" data-href="#概述" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#概述" class="internal-link" target="_self" rel="noopener">概述</a> <br><a data-tooltip-position="top" aria-label="什么是 Spring Boot？" data-href="#什么是 Spring Boot？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Spring_Boot？" class="internal-link" target="_self" rel="noopener">什么是 Spring Boot？</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 有哪些优点？" data-href="#Spring Boot 有哪些优点？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_有哪些优点？" class="internal-link" target="_self" rel="noopener">Spring Boot 有哪些优点？</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？" data-href="#Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_的核心注解是哪个？它主要由哪几个注解组成的？" class="internal-link" target="_self" rel="noopener">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</a> <br><a data-tooltip-position="top" aria-label="配置" data-href="#配置" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#配置" class="internal-link" target="_self" rel="noopener">配置</a> <br><a data-tooltip-position="top" aria-label="什么是 JavaConfig？" data-href="#什么是 JavaConfig？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_JavaConfig？" class="internal-link" target="_self" rel="noopener">什么是 JavaConfig？</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 自动配置原理是什么？" data-href="#Spring Boot 自动配置原理是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_自动配置原理是什么？" class="internal-link" target="_self" rel="noopener">Spring Boot 自动配置原理是什么？</a>
<br><a data-tooltip-position="top" aria-label="你如何理解 Spring Boot 配置加载顺序？" data-href="#你如何理解 Spring Boot 配置加载顺序？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#你如何理解_Spring_Boot_配置加载顺序？" class="internal-link" target="_self" rel="noopener">你如何理解 Spring Boot 配置加载顺序？</a>
<br><a data-tooltip-position="top" aria-label="什么是 YAML？" data-href="#什么是 YAML？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_YAML？" class="internal-link" target="_self" rel="noopener">什么是 YAML？</a>
<br><a data-tooltip-position="top" aria-label="YAML 配置的优势在哪里 ?" data-href="#YAML 配置的优势在哪里 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#YAML_配置的优势在哪里_" class="internal-link" target="_self" rel="noopener">YAML 配置的优势在哪里 ?</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 是否可以使用 XML 配置 ?" data-href="#Spring Boot 是否可以使用 XML 配置 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_是否可以使用_XML_配置_" class="internal-link" target="_self" rel="noopener">Spring Boot 是否可以使用 XML 配置 ?</a>
<br><a data-tooltip-position="top" aria-label="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?" data-href="#spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#spring_boot_核心配置文件是什么？bootstrap.properties_和_application.properties_有何区别_" class="internal-link" target="_self" rel="noopener">spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</a>
<br><a data-tooltip-position="top" aria-label="什么是 Spring Profiles？" data-href="#什么是 Spring Profiles？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Spring_Profiles？" class="internal-link" target="_self" rel="noopener">什么是 Spring Profiles？</a>
<br><a data-tooltip-position="top" aria-label="如何在自定义端口上运行 Spring Boot 应用程序？" data-href="#如何在自定义端口上运行 Spring Boot 应用程序？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何在自定义端口上运行_Spring_Boot_应用程序？" class="internal-link" target="_self" rel="noopener">如何在自定义端口上运行 Spring Boot 应用程序？</a> <br><a data-tooltip-position="top" aria-label="安全" data-href="#安全" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#安全" class="internal-link" target="_self" rel="noopener">安全</a> <br><a data-tooltip-position="top" aria-label="如何实现 Spring Boot 应用程序的安全性？" data-href="#如何实现 Spring Boot 应用程序的安全性？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何实现_Spring_Boot_应用程序的安全性？" class="internal-link" target="_self" rel="noopener">如何实现 Spring Boot 应用程序的安全性？</a>
<br><a data-tooltip-position="top" aria-label="比较一下 Spring Security 和 Shiro 各自的优缺点 ?" data-href="#比较一下 Spring Security 和 Shiro 各自的优缺点 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#比较一下_Spring_Security_和_Shiro_各自的优缺点_" class="internal-link" target="_self" rel="noopener">比较一下 Spring Security 和 Shiro 各自的优缺点 ?</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 中如何解决跨域问题 ?" data-href="#Spring Boot 中如何解决跨域问题 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_中如何解决跨域问题_" class="internal-link" target="_self" rel="noopener">Spring Boot 中如何解决跨域问题 ?</a>
<br><a data-tooltip-position="top" aria-label="什么是 CSRF 攻击？" data-href="#什么是 CSRF 攻击？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_CSRF_攻击？" class="internal-link" target="_self" rel="noopener">什么是 CSRF 攻击？</a> <br><a data-tooltip-position="top" aria-label="监视器" data-href="#监视器" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#监视器" class="internal-link" target="_self" rel="noopener">监视器</a> <br><a data-tooltip-position="top" aria-label="Spring Boot 中的监视器是什么？" data-href="#Spring Boot 中的监视器是什么？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_中的监视器是什么？" class="internal-link" target="_self" rel="noopener">Spring Boot 中的监视器是什么？</a>
<br><a data-tooltip-position="top" aria-label="如何在 Spring Boot 中禁用 Actuator 端点安全性？" data-href="#如何在 Spring Boot 中禁用 Actuator 端点安全性？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何在_Spring_Boot_中禁用_Actuator_端点安全性？" class="internal-link" target="_self" rel="noopener">如何在 Spring Boot 中禁用 Actuator 端点安全性？</a>
<br><a data-tooltip-position="top" aria-label="我们如何监视所有 Spring Boot 微服务？" data-href="#我们如何监视所有 Spring Boot 微服务？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#我们如何监视所有_Spring_Boot_微服务？" class="internal-link" target="_self" rel="noopener">我们如何监视所有 Spring Boot 微服务？</a> <br><a data-tooltip-position="top" aria-label="整合第三方项目" data-href="#整合第三方项目" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#整合第三方项目" class="internal-link" target="_self" rel="noopener">整合第三方项目</a> <br><a data-tooltip-position="top" aria-label="什么是 WebSockets？" data-href="#什么是 WebSockets？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_WebSockets？" class="internal-link" target="_self" rel="noopener">什么是 WebSockets？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Spring Data ?" data-href="#什么是 Spring Data ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Spring_Data_" class="internal-link" target="_self" rel="noopener">什么是 Spring Data ?</a>
<br><a data-tooltip-position="top" aria-label="什么是 Spring Batch？" data-href="#什么是 Spring Batch？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Spring_Batch？" class="internal-link" target="_self" rel="noopener">什么是 Spring Batch？</a>
<br><a data-tooltip-position="top" aria-label="什么是 FreeMarker 模板？" data-href="#什么是 FreeMarker 模板？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_FreeMarker_模板？" class="internal-link" target="_self" rel="noopener">什么是 FreeMarker 模板？</a>
<br><a data-tooltip-position="top" aria-label="如何集成 Spring Boot 和 ActiveMQ？" data-href="#如何集成 Spring Boot 和 ActiveMQ？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何集成_Spring_Boot_和_ActiveMQ？" class="internal-link" target="_self" rel="noopener">如何集成 Spring Boot 和 ActiveMQ？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Apache Kafka？" data-href="#什么是 Apache Kafka？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Apache_Kafka？" class="internal-link" target="_self" rel="noopener">什么是 Apache Kafka？</a>
<br><a data-tooltip-position="top" aria-label="什么是 Swagger？你用 Spring Boot 实现了它吗？" data-href="#什么是 Swagger？你用 Spring Boot 实现了它吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#什么是_Swagger？你用_Spring_Boot_实现了它吗？" class="internal-link" target="_self" rel="noopener">什么是 Swagger？你用 Spring Boot 实现了它吗？</a>
<br><a data-tooltip-position="top" aria-label="前后端分离，如何维护接口文档 ?" data-href="#前后端分离，如何维护接口文档 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#前后端分离，如何维护接口文档_" class="internal-link" target="_self" rel="noopener">前后端分离，如何维护接口文档 ?</a> <br><a data-tooltip-position="top" aria-label="其他" data-href="#其他" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#其他" class="internal-link" target="_self" rel="noopener">其他</a> <br><a data-tooltip-position="top" aria-label="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？" data-href="#如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何重新加载_Spring_Boot_上的更改，而无需重新启动服务器？Spring_Boot项目如何热部署？" class="internal-link" target="_self" rel="noopener">如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</a>
<br><a data-tooltip-position="top" aria-label="您使用了哪些 starter maven 依赖项？" data-href="#您使用了哪些 starter maven 依赖项？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#您使用了哪些_starter_maven_依赖项？" class="internal-link" target="_self" rel="noopener">您使用了哪些 starter maven 依赖项？</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 中的 starter 到底是什么 ?" data-href="#Spring Boot 中的 starter 到底是什么 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_中的_starter_到底是什么_" class="internal-link" target="_self" rel="noopener">Spring Boot 中的 starter 到底是什么 ?</a>
<br><a data-tooltip-position="top" aria-label="spring-boot-starter-parent 有什么用 ?" data-href="#spring-boot-starter-parent 有什么用 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#spring-boot-starter-parent_有什么用_" class="internal-link" target="_self" rel="noopener">spring-boot-starter-parent 有什么用 ?</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?" data-href="#Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_打成的_jar_和普通的_jar_有什么区别_" class="internal-link" target="_self" rel="noopener">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</a>
<br><a data-tooltip-position="top" aria-label="运行 Spring Boot 有哪几种方式？" data-href="#运行 Spring Boot 有哪几种方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#运行_Spring_Boot_有哪几种方式？" class="internal-link" target="_self" rel="noopener">运行 Spring Boot 有哪几种方式？</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 需要独立的容器运行吗？" data-href="#Spring Boot 需要独立的容器运行吗？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_需要独立的容器运行吗？" class="internal-link" target="_self" rel="noopener">Spring Boot 需要独立的容器运行吗？</a>
<br><a data-tooltip-position="top" aria-label="开启 Spring Boot 特性有哪几种方式？" data-href="#开启 Spring Boot 特性有哪几种方式？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#开启_Spring_Boot_特性有哪几种方式？" class="internal-link" target="_self" rel="noopener">开启 Spring Boot 特性有哪几种方式？</a>
<br><a data-tooltip-position="top" aria-label="如何使用 Spring Boot 实现异常处理？" data-href="#如何使用 Spring Boot 实现异常处理？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何使用_Spring_Boot_实现异常处理？" class="internal-link" target="_self" rel="noopener">如何使用 Spring Boot 实现异常处理？</a>
<br><a data-tooltip-position="top" aria-label="如何使用 Spring Boot 实现分页和排序？" data-href="#如何使用 Spring Boot 实现分页和排序？" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#如何使用_Spring_Boot_实现分页和排序？" class="internal-link" target="_self" rel="noopener">如何使用 Spring Boot 实现分页和排序？</a>
<br><a data-tooltip-position="top" aria-label="微服务中如何实现 session 共享 ?" data-href="#微服务中如何实现 session 共享 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#微服务中如何实现_session_共享_" class="internal-link" target="_self" rel="noopener">微服务中如何实现 session 共享 ?</a>
<br><a data-tooltip-position="top" aria-label="Spring Boot 中如何实现定时任务 ?" data-href="#Spring Boot 中如何实现定时任务 ?" href="https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html#Spring_Boot_中如何实现定时任务_" class="internal-link" target="_self" rel="noopener">Spring Boot 中如何实现定时任务 ?</a> <br><br><br>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。<br><br>Spring Boot 主要有如下优点：<br>
<br>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。
<br>开箱即用，远离繁琐的配置。
<br>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
<br>没有代码生成，也不需要XML配置。
<br>避免大量的 Maven 导入和各种版本冲突。
<br><br>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<br>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。<br>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。<br>@ComponentScan：Spring组件扫描。<br><br><br>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<br>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。<br>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。<br>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。<br><br>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，<br>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。<br>筛选有效的自动配置类。<br>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能<br><br>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<br>1）properties文件；<br>2）YAML文件；<br>3）系统环境变量；<br>4）命令行参数；<br>等等……<br><br>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。<br><br>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<br>
<br>配置有序，在一些特殊的场景下，配置有序很关键
<br>支持数组，数组中的元素可以是基本数据类型也可以是对象
<br>简洁
<br>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。<br><br>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。<br><br>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。<br>spring boot 核心的两个配置文件：<br>
<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；
<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
<br><br>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。<br><br>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090<br><br><br>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。<br><br>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：<br>
<br>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架
<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单
<br>Spring Security 功能强大；Shiro 功能简单
<br><br>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。<br>@Configuration
public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedOrigins("*") .allowCredentials(true) .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") .maxAge(3600); } }
复制<br>项目中前后端分离部署，所以需要解决跨域的问题。<br>
我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>
当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>
我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。<br>@Configuration
public class CorsConfig { @Bean public CorsFilter corsFilter() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); corsConfiguration.setAllowCredentials(true); UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration); return new CorsFilter(urlBasedCorsConfigurationSource); } }
复制<br><br>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。<br><br><br>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。<br><br>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。<br><br>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。<br><br><br>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。<br>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。<br>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。<br>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信<br>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。<br><br>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：<br>SpringData 项目支持 NoSQL 存储：<br>
<br>MongoDB （文档数据库）
<br>Neo4j（图形数据库）
<br>Redis（键/值存储）
<br>Hbase（列族数据库）
<br>SpringData 项目所支持的关系数据存储技术：<br>
<br>JDBC
<br>JPA
<br>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。<br><br>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。<br><br>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。<br><br>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。<br><br>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。<br><br>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。<br><br>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。<br><br><br>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。<br>&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;` 复制<br><br>使用了下面的一些依赖项<br>spring-boot-starter-activemq<br>spring-boot-starter-security<br>这有助于增加更少的依赖关系，并减少版本的冲突。<br><br>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter<br><br>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：<br>
<br>定义了 Java 编译版本为 1.8 。
<br>使用 UTF-8 格式编码。
<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。
<br>执行打包操作的配置。
<br>自动化的资源过滤。
<br>自动化的插件配置。
<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。
<br><br>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。<br>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。<br><br>1）打包用命令或者放到容器中运行<br>2）用 Maven/ Gradle 插件运行<br>3）直接执行 main 方法运行<br><br>可以不需要，内置了 Tomcat/ Jetty 等容器。<br><br>1）继承spring-boot-starter-parent项目<br>2）导入spring-boot-dependencies项目依赖<br><br>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。<br><br>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。<br><br>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。<br><br>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。<br>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。<br>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。<br>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/面试资料/spring-boot面试题（2020最新版）.html</link><guid isPermaLink="false">知识库/工作技能/面试资料/Spring Boot面试题（2020最新版）.md</guid><pubDate>Wed, 19 Jun 2024 15:37:32 GMT</pubDate></item><item><title><![CDATA[SpringBoot 启动扩展点_常用接口_springboot 有哪些拓展点接口]]></title><description><![CDATA[<br>
<br><a data-tooltip-position="top" aria-label="SpringBoot常用的接口" data-href="#SpringBoot常用的接口" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#SpringBoot常用的接口" class="internal-link" target="_self" rel="noopener">SpringBoot常用的接口</a>
<br><a data-tooltip-position="top" aria-label="ApplicationContextInitializer" data-href="#ApplicationContextInitializer" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#ApplicationContextInitializer" class="internal-link" target="_self" rel="noopener">ApplicationContextInitializer</a>
<br><a data-tooltip-position="top" aria-label="BeanDefinitionRegistryPostProcessor" data-href="#BeanDefinitionRegistryPostProcessor" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#BeanDefinitionRegistryPostProcessor" class="internal-link" target="_self" rel="noopener">BeanDefinitionRegistryPostProcessor</a>
<br><a data-tooltip-position="top" aria-label="BeanFactoryPostProcessor" data-href="#BeanFactoryPostProcessor" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#BeanFactoryPostProcessor" class="internal-link" target="_self" rel="noopener">BeanFactoryPostProcessor</a>
<br><a data-tooltip-position="top" aria-label="InstantiationAwareBeanPostProcessor" data-href="#InstantiationAwareBeanPostProcessor" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#InstantiationAwareBeanPostProcessor" class="internal-link" target="_self" rel="noopener">InstantiationAwareBeanPostProcessor</a>
<br><a data-tooltip-position="top" aria-label="SmartInstantiationAwareBeanPostProcessor" data-href="#SmartInstantiationAwareBeanPostProcessor" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#SmartInstantiationAwareBeanPostProcessor" class="internal-link" target="_self" rel="noopener">SmartInstantiationAwareBeanPostProcessor</a>
<br><a data-tooltip-position="top" aria-label="BeanFactoryAware" data-href="#BeanFactoryAware" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#BeanFactoryAware" class="internal-link" target="_self" rel="noopener">BeanFactoryAware</a>
<br><a data-tooltip-position="top" aria-label="ApplicationContextAwareProcessor" data-href="#ApplicationContextAwareProcessor" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#ApplicationContextAwareProcessor" class="internal-link" target="_self" rel="noopener">ApplicationContextAwareProcessor</a>
<br><a data-tooltip-position="top" aria-label="BeanNameAware" data-href="#BeanNameAware" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#BeanNameAware" class="internal-link" target="_self" rel="noopener">BeanNameAware</a>
<br><a data-tooltip-position="top" aria-label="@PostConstruct" data-href="#@PostConstruct" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#@PostConstruct" class="internal-link" target="_self" rel="noopener">@PostConstruct</a>
<br><a data-tooltip-position="top" aria-label="InitializingBean" data-href="#InitializingBean" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#InitializingBean" class="internal-link" target="_self" rel="noopener">InitializingBean</a>
<br><a data-tooltip-position="top" aria-label="FactoryBean" data-href="#FactoryBean" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#FactoryBean" class="internal-link" target="_self" rel="noopener">FactoryBean</a>
<br><a data-tooltip-position="top" aria-label="SmartInitializingSingleton" data-href="#SmartInitializingSingleton" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#SmartInitializingSingleton" class="internal-link" target="_self" rel="noopener">SmartInitializingSingleton</a>
<br><a data-tooltip-position="top" aria-label="CommandLineRunner" data-href="#CommandLineRunner" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#CommandLineRunner" class="internal-link" target="_self" rel="noopener">CommandLineRunner</a>
<br><a data-tooltip-position="top" aria-label="DisposableBean" data-href="#DisposableBean" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#DisposableBean" class="internal-link" target="_self" rel="noopener">DisposableBean</a>
<br><a data-tooltip-position="top" aria-label="ApplicationListener" data-href="#ApplicationListener" href="https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html#ApplicationListener" class="internal-link" target="_self" rel="noopener">ApplicationListener</a>
<br><br>1、BeanFactoryAware接口 暴露BeanFactory ：实现该接口方法可以拿到暴露BeanFactory<br>2、ResourceLoaderAware接口 暴露ResourceLoader： 实现该接口获取资源加载器,可以获得外部资源文件<br>3、BeanNameAware接口 暴露beanName: 实现该接口可以获取bean名字<br>4、MessageSourceAware接口 暴露MessageSource：实现该接口可以设置国际化信息替换<br>5、EnvironmentAware接口 暴露Environment：获取所有配置信息继承PropertyResolver可以获取key-value<br>6、ApplicationContextAware接口 暴露ApplicationContext：实现该接口可以获取到容器上下文(ApplicationContext接口继承BeanFactory，包括Environment、MessageSource、ApplicationEventPublisher、ResourceLoader基本上涵盖以上所有作用)<br>7、ServletContextAware接口 暴露ServletContext：获取Servlet上下文信息<br>8、ServletConfigAware接口 暴露ServletConfig：包括可以获取ServletContext<br>9、InstantiationAwareBeanPostProcessor接口 在Bean实例化前后做一些操作。这个接口实际上我们也是非常的熟悉，该接口在我们剖析注解配置AOP的时候是我们的老朋友，实际上，注解配置的AOP是间接实现 BeanPostProcess 接口的，而 InstantiationAwareBeanPostProcessor 就是继承该接口<br>10、<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=CommandLineRunner&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=CommandLineRunner&amp;spm=1001.2101.3001.7020" target="_self">CommandLineRunner</a>接口 容器初始化完成后执行，可获取设置的环境变量参数<br>11、<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=ApplicationRunner&amp;spm=1001.2101.3001.7020" rel="noopener" class="external-link is-unresolved" href="https://so.csdn.net/so/search?q=ApplicationRunner&amp;spm=1001.2101.3001.7020" target="_self">ApplicationRunner</a>接口 容器初始化完成后执行代码<br>12、BeanPostProcessor接口 ： bean实例化前后处理，实现该接口可以在bean实例化前后进行操作，与之类似接口BeanFactoryPostProcessor该接口在注册bean（BeanDefinitionsMap）后的操作<br>13、InitializingBean接口 :initializeBean时执行，即BeanPostProcessor执行完before后执行该接口方法afterPropertiesSet<br>14、ImportBeanDefinitionRegistrar接口： registerBeanDefinitions bean注册到BeanDefinitionsMap<br>15、ImportSelector接口，返回所有classname数组,在注册bean是调用获取，之后放入BeanDefinitionsMap与ImportBeanDefinitionRegistrar有点类似作用<br>16、DeferredImportSelector接口：继承ImportSelector接口，作用差不多，只不过该接口延迟被注册，ImportSelector接口注册完bean之后才会接着注册DeferredImportSelector的bean<br>17、ApplicationListener接口: 监听接口，当bean被初始化完成并被成功装载后会触发该事件，在最后一步finishRefresh时调用，实现ApplicationListener接口可以收到监听动作<br>18、ApplicationContextInitializer接口： 刷新容器前也就是prepareContext时遍历调用，也就是bean注册前调用<br>19、FactoryBean接口：自定义Bean的创建过程,将对象放入beanFactory<br><img alt="b263be4b3833ff3d6ef91a4bb82612c0_MD5.png" src="https://pages-9hu.pages.dev/attachments/b263be4b3833ff3d6ef91a4bb82612c0_md5.png" target="_self"><br><br>
org.springframework.context.ApplicationContextInitializer
<br>这是整个spring容器在刷新之前初始化ConfigurableApplicationContext的回调接口，简单来说，就是在容器刷新之前调用此类的initialize方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。<br>ApplicationContextInitializer是Spring框架原有的概念, 这个类的主要目的就是在ConfigurableApplicationContext类型（或者子类型）的ApplicationContext做refresh之前，允许我们对ConfigurableApplicationContext的实例做进一步的设置或者处理。<br>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。<br>public class MyApplicationContextInitializer implements ApplicationContextInitializer { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println("-----MyApplicationContextInitializer initialize-----"); }
}
复制<br>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：<br>方式一、启动类使用SpringApplication对象添加<br>@SpringBootApplication
public class SpringExtApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(SpringExtApplication.class); application.addInitializers(new MyApplicationContextInitializer()); application.run(args); }
}
复制<br>方式二、application.yml/application.properties配置文件配置<br># yml
context: initializer: classes: cn.zysheep.ext.MyApplicationContextInitializer # properties
context.initializer.classes=cn.zysheep.ext.MyApplicationContextInitializer
复制<br>方式三、Spring SPI扩展，在resources/META-INF/spring.factories中加入<br># Initializers
org.springframework.context.ApplicationContextInitializer=\ cn.zysheep.ext.MyApplicationContextInitializer 复制<br>三种方式同时配置，会同时生效<br><br>
org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor
<br>这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点<br>使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean<br>public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor { @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { System.out.println("[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry"); } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println("[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory"); }
}
复制<br><br>
org.springframework.beans.factory.config.BeanFactoryPostProcessor
<br>这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。<br>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。<br>public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println("[BeanFactoryPostProcessor]"); }
}
复制<br><br>
org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor
<br>该接口继承了BeanPostProcess接口，区别如下：<br>BeanPostProcess接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。 <br>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：实例化阶段和初始化阶段，下面一起进行说明，按调用顺序为：<br>
<br>postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前
<br>postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后
<br>postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired,@Resource等注解原理基于此方法实现
<br>postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前
<br>postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后
<br>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。<br>public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println("[TestInstantiationAwareBeanPostProcessor] before initialization " + beanName); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println("[TestInstantiationAwareBeanPostProcessor] after initialization " + beanName); return bean; } @Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException { System.out.println("[TestInstantiationAwareBeanPostProcessor] before instantiation " + beanName); return null; } @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { System.out.println("[TestInstantiationAwareBeanPostProcessor] after instantiation " + beanName); return true; } @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException { System.out.println("[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues " + beanName); return pvs; }
复制<br><br>
org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor
<br>该扩展接口有3个触发点方法：<br>
<br>predictBeanType：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。
<br>determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。
<br>getEarlyBeanReference：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。
<br>扩展方式为：<br>public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor { @Override public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException { System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType " + beanName); return beanClass; } @Override public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException { System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors " + beanName); return null; } @Override public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException { System.out.println("[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference " + beanName); return bean; }
}
复制<br><br>
org.springframework.beans.factory.BeanFactoryAware
<br>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为setBeanFactory，可以拿到BeanFactory这个属性。<br>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。<br>扩展方式为：<br>public class TestBeanFactoryAware implements BeanFactoryAware { @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { System.out.println("[TestBeanFactoryAware] " + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName()); }
}
复制<br><br>
org.springframework.context.support.ApplicationContextAwareProcessor
<br>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前<br><img alt="90757167dee13cfb0228dce39fe6d400_MD5.png" src="https://pages-9hu.pages.dev/attachments/90757167dee13cfb0228dce39fe6d400_md5.png" target="_self"><br>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。所以这里应该来说是有6个扩展点，这里就放一起来说了<br>
<br>EnvironmentAware：用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。
<br>EmbeddedValueResolverAware：用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。
<br>ResourceLoaderAware：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。
<br>ApplicationEventPublisherAware：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。
<br>MessageSourceAware：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。
<br>ApplicationContextAware：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。
<br><br>
org.springframework.beans.factory.BeanNameAware
<br>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName<br>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。<br>扩展方式为：<br>public class NormalBeanA implements BeanNameAware{ public NormalBeanA() { System.out.println("NormalBean constructor"); } @Override public void setBeanName(String name) { System.out.println("[BeanNameAware] " + name); }
}
复制<br><br>
javax.annotation.PostConstruct
<br>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。<br>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性<br>扩展方式为：<br>public class NormalBeanA { public NormalBeanA() { System.out.println("NormalBean constructor"); } @PostConstruct public void init(){ System.out.println("[PostConstruct] NormalBeanA"); }
}
复制<br><br>
org.springframework.beans.factory.InitializingBean
<br>这个类，顾名思义，也是用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。<br>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。<br>扩展方式为：<br>public class NormalBeanA implements InitializingBean{ @Override public void afterPropertiesSet() throws Exception { System.out.println("[InitializingBean] NormalBeanA"); }
}
复制<br><br>
org.springframework.beans.factory.FactoryBean
<br>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean&lt;T&gt;的形式<br>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。<br>扩展方式为：<br>public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; { @Override public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception { System.out.println("[FactoryBean] getObject"); return new TestFactoryBean.TestFactoryInnerBean(); } @Override public Class&lt;?&gt; getObjectType() { return TestFactoryBean.TestFactoryInnerBean.class; } @Override public boolean isSingleton() { return true; } public static class TestFactoryInnerBean{ }
}
复制<br><br>
org.springframework.beans.factory.SmartInitializingSingleton
<br>这个接口中只有一个方法afterSingletonsInstantiated，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为postProcessAfterInitialization之后。<br>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。<br>扩展方式为：<br>public class TestSmartInitializingSingleton implements SmartInitializingSingleton { @Override public void afterSingletonsInstantiated() { System.out.println("[TestSmartInitializingSingleton]"); }
}
复制<br><br>
org.springframework.boot.CommandLineRunner
<br>这个接口也只有一个方法：run(String... args)，触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。<br>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。<br>扩展方式为：<br>public class TestCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println("[TestCommandLineRunner]"); }
}
复制<br><br>
org.springframework.beans.factory.DisposableBean
<br>这个扩展点也只有一个方法：destroy()，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。<br>扩展方式为：<br>public class NormalBeanA implements DisposableBean { @Override public void destroy() throws Exception { System.out.println("[DisposableBean] NormalBeanA"); }
}
复制<br><br>
org.springframework.context.ApplicationListener
<br>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，ApplicationListener可以监听某个事件的event，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。<br>接下来罗列下spring主要的内置事件：<br>
<br>ContextRefreshedEvent<br>
ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用。
<br>ContextStartedEvent<br>
当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。
<br>ContextStoppedEvent<br>
当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作
<br>ContextClosedEvent<br>
当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启
<br>RequestHandledEvent<br>
这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件
]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/spring/springboot-启动扩展点_常用接口_springboot-有哪些拓展点接口.html</link><guid isPermaLink="false">知识库/工作技能/spring/SpringBoot 启动扩展点_常用接口_springboot 有哪些拓展点接口.md</guid><pubDate>Wed, 19 Jun 2024 15:32:38 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/b263be4b3833ff3d6ef91a4bb82612c0_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/b263be4b3833ff3d6ef91a4bb82612c0_md5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spring框架中的Bean生命周期]]></title><description><![CDATA[<br>Spring框架中的Bean生命周期可以概括为以下几个阶段：<br>
<br>实例化（Instantiation）：Spring容器通过反射或者工厂方法创建Bean的实例。
<br>属性赋值（Populate Properties）：为Bean的属性设置值和对其他Bean的引用。
<br>初始化（Initialization）：如果Bean实现了BeanNameAware, BeanFactoryAware, ApplicationContextAware等接口，会调用对应的方法。然后，如果BeanPostProcessor被注册，Bean实例将被传递给postProcessBeforeInitialization()方法。随后，如果Bean定义了初始化方法（比如使用@PostConstruct注解），它将被调用。最后，如果有BeanPostProcessor注册，Bean实例将被传递给postProcessAfterInitialization()方法。
<br>使用（In use）：Bean现在可以被应用程序使用了。
<br>销毁（Destruction）：如果Bean实现了DisposableBean接口，destroy()方法会被调用。或者，如果Bean定义了销毁方法（比如使用@PreDestroy注解），它将被调用。
<br>以下是一个简单的Spring Bean的定义和生命周期的代码示例：<br>import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
@Component
@Scope("prototype")
public class MyBean implements BeanNameAware, InitializingBean, DisposableBean { private String beanName; public MyBean() { System.out.println("实例化 MyBean"); } @Override public void setBeanName(String name) { this.beanName = name; System.out.println("设置Bean名称: " + name); } @Override public void afterPropertiesSet() throws Exception { System.out.println("属性设置完成后的回调"); } public void customInit() { System.out.println("自定义初始化方法"); } public void customDestroy() { System.out.println("自定义销毁方法"); } @Override public void destroy() throws Exception { System.out.println("实现DisposableBean接口的destroy方法"); }
}
复制<br>在Spring配置中，你可以这样配置以使用自定义的初始化和销毁方法：<br>&lt;bean id="myBean" class="com.example.MyBean" init-method="customInit" destroy-method="customDestroy"/&gt;
复制<br>或者使用Java配置：<br>@Bean(initMethod = "customInit", destroyMethod = "customDestroy")public MyBean myBean() { return new MyBean();
}
复制<br>这段代码展示了如何定义一个Bean，并在Spring容器中的不同生命周期阶段执行特定的操作。]]></description><link>https://pages-9hu.pages.dev/知识库/工作技能/spring/spring框架中的bean生命周期.html</link><guid isPermaLink="false">知识库/工作技能/spring/Spring框架中的Bean生命周期.md</guid><pubDate>Wed, 19 Jun 2024 14:53:46 GMT</pubDate></item><item><title><![CDATA[DataView 查询语法]]></title><description><![CDATA[<a class="tag" href="https://pages-9hu.pages.dev/?query=tag:标签" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#标签</a> <a class="tag" href="https://pages-9hu.pages.dev/?query=tag:标签" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#标签</a> <br> ```dataview
&lt;QUERY-TYPE&gt; &lt;WITHOUT ID&gt; &lt;字段&gt;
FROM &lt;来源&gt;
&lt;WHERE&gt; &lt;条件表达式&gt;
&lt;SORT&gt; &lt;排序依据 排序方式&gt;
&lt;GROUP BY&gt; &lt;分组依据&gt;
&lt;LIMIT&gt; &lt;限定显示记录数&gt;
&lt;FLATTEN&gt; &lt;拆分表达式&gt;
```
复制<br>以表格的形式显示符合查询条件的文件清单和相关属性。<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", aliases as "别名", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
SORT file.cday DESC
```
复制<br>以无序列表的形式显示符合查询条件的文件清单。<br>```dataview
LIST
FROM "200-学习箱/210-知识库搭建"
```
复制<br>仅以任务列表的形式显示符合查询条件的任务列表。<br>```dataview
TASK
FROM "200-学习箱/210-知识库搭建"
```
复制<br>以日历视图的形式显示查询结果，日历现在还有个 Bug，经常会显示两个重复月份的日历。<br>```dataview
CALENDAR file.cday
WHERE contains(file.name, "PicGo")
```
//必须加日期型的字段作为日历中的定位
CALENDAR file.cday
WHERE contains(file.name, "PicGo")
复制<br>:&nbsp;之前的为属性名，直接使用，不需要&nbsp;file.属性<br>查询实例<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", aliases as "别名", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
SORT file.cday DESC
```
复制<br>```dataview
LIST
FROM #DataView ```
复制<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", aliases as "别名", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
SORT file.cday DESC
```
TABLE WITHOUT ID file.link as "文件名称", aliases as "别名", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
SORT file.cday DESC
```
复制<br>```dataview
TABLE WITHOUT ID file.link as "文件名", file.tasks.text as "任务名", choice(file.tasks.completed, "是", "否") as "已完成"
FROM "200-学习箱/210-知识库搭建/Markdown for macOS"
```
复制<br>```dataview
LIST
FROM [[内部文件链接]] ```
//查询 [[内部文件链接]] 被哪些文件链接，即入链 ```dataview
LIST
FROM outgoing([[Markdown for macOS]]) ```
复制<br>即将 1、2、4 来源联合起来使用<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", aliases as "别名", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建" and outgoing([[Markdown for macOS]])
SORT file.cday DESC
```
复制<br>
<br>1. 包含指定文本
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE icontains(file.name,"obsidian")
``` // contains(file.name,"obsidian") 大小写敏感
// icontains(file.name,"obsidian") 大小写不敏感
复制<br>2. 不包含指定文本
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE !icontains(file.name,"obsidian")
```
复制<br>3. 以特定文本开头
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE startswith(file.name,"Obsidian")
```
复制<br>4. 以特定文本结尾
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE endswith(file.name,"COS")
```
复制<br>5. 英文大小写转换
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE endswith(lower(file.name),"cos")
``` ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE startswith(upper(file.name),"OBSIDIAN")
```
复制<br>
<br>1. 等于与不等于
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE number1 = 9
``` ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE !(number1 = 9)
```
复制<br>2. 大于或大于等于
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE number1 &gt;= 8
```
复制<br>
<br>3. 小于或小于等于
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE number1 &lt;= 9
``` // 当文件 YAML 没有定义该属性时，该属性值默认为 0
复制<br>4. 数字的四则运算
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE number1 - number1 &lt;= 0
```
复制<br>
<br>1. 日期的格式化
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", dateformat(file.ctime,"HH:mm: ss") as "创建时间", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday &lt;= date("2023-02-20")
``` //日期格式化通常只作为输出显示格式定义，不作为条件
复制<br>2. 等于指定日期
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday = date("2023-02-19")
```
复制<br>3. 大于等于指定日期
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday &gt;= date("2023-02-19")
```
复制<br>4. 小于等于指定日期
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday &lt;= date("2023-02-20")
```
复制<br>5. 常用的日期属性
<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday.month = date(today).month
``` // year
// month
// day
// date (today)
// date (now)
// date (tomorrow)
// date (yesterday)
// date (sow)
// date (eow) ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.cday &gt;= date(sow) and file.cday &lt;= date(eow)
```
复制<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE file.starred
``` ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE !file.starred
``` ```dataview
TASK
WHERE !fullyCompleted
```
// 如果本级任务未完成，下级任务已完成，会将下级已完成的一起显示 ```dataview
TASK
WHERE fullyCompleted
```
复制<br>Boolean 类字段的格式化，就是将 true、false 转换为更偏于用户阅读的是 / 否，或者是 yes / no<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE contains(tags,"DataView")
``` ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE !contains(tags,"DataView")
```
// 如果 YAML 中没有定议 tags，则默认为空
复制<br>```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE contains(file.outlinks, [[内部文件链接]])
``` ```dataview
TABLE WITHOUT ID file.link as "文件名称", dateformat(file.cday,"yyyy-MM-dd") as "创建日期", choice(file.starred, "是", "否") as "加星"
FROM "200-学习箱/210-知识库搭建"
WHERE contains(file.inlinks, [[Markdown for macOS]])
```
复制<br>&lt;条件1&gt; and &lt;条件2&gt; 1. 只满足&lt;条件1&gt;，不会被显示到查询结果中
2. 只满足&lt;条件2&gt;，不会被显示到查询结果中
3. 同时满足&lt;条件1&gt;和&lt;条件2&gt;，会显示到查询结果中
复制<br>&lt;条件1&gt; or &lt;条件2&gt; 1. 只满足&lt;条件1&gt;，会被显示到查询结果中
2. 只满足&lt;条件2&gt;，会被显示到查询结果中
3. 同时满足&lt;条件1&gt;和&lt;条件2&gt;，会显示到查询结果中
复制<br>仅发生在需要同时运用 and 和 or 两个边接符时，才需要使用括号定义优先级 （&lt;条件1&gt; or &lt;条件2&gt;) and &lt;条件3&gt; 1. 只满足&lt;条件1&gt;，不会被显示到查询结果中
2. 只满足&lt;条件2&gt;，不会被显示到查询结果中
3. 只满足&lt;条件3&gt;，不会被显示到查询结果中
4. 同时满足&lt;条件1&gt;和&lt;条件2&gt;，不会显示到查询结果中
5. 同时满足&lt;条件1&gt;和&lt;条件3&gt;，会显示到查询结果中
6. 同时满足&lt;条件2&gt;和&lt;条件3&gt;，会显示到查询结果中
7. 同时满足&lt;条件1&gt;、&lt;条件2&gt;和&lt;条件3&gt;，会显示到查询结果中
仅发生在需要同时运用 and 和 or 两个边接符时，才需要使用括号定义优先级 （&lt;条件1&gt; and &lt;条件2&gt;) or &lt;条件3&gt; 1. 只满足&lt;条件1&gt;，不会被显示到查询结果中
2. 只满足&lt;条件2&gt;，不会被显示到查询结果中
3. 只满足&lt;条件3&gt;，会被显示到查询结果中
4. 同时满足&lt;条件1&gt;和&lt;条件2&gt;，会显示到查询结果中
5. 同时满足&lt;条件1&gt;和&lt;条件3&gt;，会显示到查询结果中
6. 同时满足&lt;条件2&gt;和&lt;条件3&gt;，会显示到查询结果中
7. 同时满足&lt;条件1&gt;、&lt;条件2&gt;和&lt;条件3&gt;，会显示到查询结果中
复制]]></description><link>https://pages-9hu.pages.dev/知识库/日常技能/obsidian/dataview-查询语法.html</link><guid isPermaLink="false">知识库/日常技能/Obsidian/DataView 查询语法.md</guid><pubDate>Tue, 18 Jun 2024 15:59:24 GMT</pubDate></item><item><title><![CDATA[1.常用插件]]></title><description><![CDATA[<br><br><img alt="attachments/Pasted image 20240616234135.png" src="https://pages-9hu.pages.dev/attachments/pasted-image-20240616234135.png" target="_self"><br><br><br><br><img alt="attachments/Pasted image 20240616235027.png" src="https://pages-9hu.pages.dev/attachments/pasted-image-20240616235027.png" target="_self"><br><br>Title
Contents
<br><img alt="attachments/Pasted image 20240617002404.png" src="https://pages-9hu.pages.dev/attachments/pasted-image-20240617002404.png" target="_self"><br><img alt="attachments/Pasted image 20240617002913.png" src="https://pages-9hu.pages.dev/attachments/pasted-image-20240617002913.png" style="width: 280px; max-width: 100%;" target="_self"><br><br><img alt="attachments/Pasted image 20240617003803.png" src="https://pages-9hu.pages.dev/attachments/pasted-image-20240617003803.png" target="_self">]]></description><link>https://pages-9hu.pages.dev/知识库/日常技能/obsidian/使用obisidian技巧.html</link><guid isPermaLink="false">知识库/日常技能/Obsidian/使用Obisidian技巧.md</guid><pubDate>Tue, 18 Jun 2024 15:12:43 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/pasted-image-20240616234135.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/pasted-image-20240616234135.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[dataview官方文档]]></title><description><![CDATA[<br>一、说明<br>对官方文档进行翻译工作<br>网站标题：dataview官方文档<br>网站地址：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//blacksmithgu.github.io/obsidian-dataview/docs/intro" rel="noopener" class="external-link is-unresolved" href="https://link.zhihu.com/?target=https%3A//blacksmithgu.github.io/obsidian-dataview/docs/intro" target="_self">https://blacksmithgu.github.io/obsidian-dataview/docs/intro</a><br>网站说明：<br><br>Dataview 是一个在你的知识库中生成数据的动态视图的高级查询引擎/索引。你可以通过使用任意和页面相关联的值，如标签(tag)，文件夹(folder)， 内容(content)，或者字段(field)来生成视图。一个使用dataview的页面一般像这样：<br># 每天回顾
# 每天
日期:: 2020-08-15
评级:: 7.5
起床:: 10:30am
睡觉:: 12:30am
复制<br>如果你有许多这样的页面，你可以通过下述代码轻松的创建一个表格：<br>```dataview
table 日期, 评级, 起床, 睡觉 from #每天 ```
复制<br>这将会生成一个像这样好看的表格：<br><img alt="e8a1c69fde1cdafa3fe4964213644b3e_MD5.webp" src="https://pages-9hu.pages.dev/attachments/e8a1c69fde1cdafa3fe4964213644b3e_md5.webp" target="_self"><br>你还可以通过过滤这个视图，仅展示高评分(rating)的一天；或者按评分对每天进行排序，亦或者按醒来的时间进行排序，诸如此类。<br><br>dataview的核心数据抽象是页面(page)&nbsp;，指在你的库中包含字段(field)&nbsp;的markdwon页面。字段&nbsp;是一段任意命名的数据 ——文本，日期，时间段，链接。 这些可被dataview理解，展示，筛选。字段可以通过三种方式定义：<br>
<br>扉页(Frontmatter): 所有的YAML 扉页内容都将自动的转换成dataview字段。
<br>内联字段(inline field): 一行格式为&lt;Name&gt;:: &lt;Value&gt;的内容将自动的被dataview解析为一个字段，请注意，你可以对&lt;Name&gt;使用标准的Markdown格式，但以后将不再支持。
<br>隐含字段(implicit): dataview自带大量的元数据对页面进行注释，如文件的创建日期、任何相关的日期、文件中的链接、标签等。
<br>用前两种方法创建的一个有相关字段的示例页面如下：<br>---
duration: 4 hours
reviewed: false
---
# Movie X **Thoughts**:: It was decent.
**Rating**:: 6
复制<br><br>dataview支持数种不同的字段类型：<br>
<br>文本(Text): 全局默认为文本。如果一个字段不匹配其它具体的类型，默认为一段纯文本。
<br>数字(Number): 数字类似于'6' 和 '3.6'。
<br>布尔值(Boolean): true/false, 就像编程中的概念。
<br>日期(Date): ISO8601 标准定义的通用日期格式&nbsp;YYYY-MM[-DDTHH:mm:ss]. 月份后面的内容都是可选的。
<br>时间段(Duration): 时间段的格式为&nbsp;&lt;time&gt; &lt;unit&gt;, 就像&nbsp;6 hours&nbsp;或者&nbsp;4 minutes。支持常见的英文缩写如6hrs&nbsp;或者&nbsp;2m&nbsp;。
<br>链接(Link): 普通的Obsidian 链接如&nbsp;[[Page]]&nbsp;或者&nbsp;[[Page|Page Display]]。
<br>列表(List): YAML中，其它dataview字段组成的列表将作为普通的YAML列表定义；对于内联字段，它们就只是逗号分隔的列表。
<br>对象(Object)：名称(name)到dataview字段的映射。这仅能在YAML扉页中利用通用的YANML对象语法进行定义。 对象语法:&nbsp;field: value1: 1 value2: 2 ...
<br>不同的字段类型非常重要。这能确保dataview理解怎样合理的对值进行比较和排序，并提供不同的操作。<br><br>dataview能自动的对每个页面添加大量的元数据。<br>
<br>file.name: 该文件标题(字符串)。
<br>file.folder: 该文件所在的文件夹的路径(字符串)。
<br>file.path: 该文件的完整路径(字符串)。
<br>file.link: 该文件的一个链接(链接)。
<br>file.size: 该文件的大小(bytes)(数字)
<br>file.ctime: 该文件的创建日期(日期和时间)。
<br>file.cday: 该文件的创建日期(仅日期)。
<br>file.mtime: 该文件最后编辑日期(日期和时间)。
<br>file.mday: 该文件最后编辑日期(仅日期)。
<br>file.tags: 笔记中所有标签组成的数组。子标签按每个级别进行细分，所以#Tag/1/A将会在数组中储存为[#Tag, #Tag/1, #Tag/1/A]。
<br>file.etags: 笔记中所有显式标签组成的数组；不同于file.tags，不包含子标签。
<br>file.outlinks: 该文件所有外链(outgoing link)组成的数组。
<br>file.aliases: 笔记中所有别名组成的数组。
<br>如果文件的标题内有一个日期（格式为yyyy-mm-dd或yyyymmdd），或者有一个Date字段/inline字段，它也有以下属性:<br>
<br>file.day: 一个该文件的隐含日期。
<br><br>一旦你给相关的页面添加了有用的数据，你就可以在某一个地方展示它或者操作它。dataview通过dataview代码块建立内联查询，写下查询代码，将会动态运行并在笔记的预览窗口展示。写这样的查询，有三种方式：<br>
<br>dataview的<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/queries" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/queries" target="_self">查询语言</a>是一个用于快速创建视图，简化的，类SQL的语言。它支持基本的算术和比较操作，对基础应用很友好。
<br>查询语言也提供内联查询，允许你直接在一个页面内嵌入单个值——通过-创建今天的日期，或者通过-来嵌入另一个页面的字段。
<br>dataview&nbsp;<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/intro" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/intro" target="_self">JavaScript API</a>为你提供了JavaScript的全部功能，并为拉取Dataview数据和执行查询提供了DSL，允许你创建任意复杂的查询和视图。
<br>与JavaScript API相比，查询语言的功能往往比较滞后，主要是因为JavaScript API更接近实际代码；相反，查询语言更稳定，在Dataview的重大更新中不太可能出现故障。<br><br>你可以在任意笔记中使用下列语法创建查询语言代码块：<br>```dataview
... query ...
```
复制<br>怎样写一个查询的细节在<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/queries" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/queries" target="_self">查询语言文档</a>中有详细阐述；如果你更倾向于学习实例，可以参看<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/examples" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/examples" target="_self">查询示例</a>。<br><br>你可以通过下列语法创建内联查询：<br>`= &lt;query language expression&gt;`
复制<br>其中表达式(expression)在<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/expressions" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/expressions" target="_self">查询语言和表达式</a>中有阐述。你可以在dataview设置中，通过使用不同的前缀(如dv:或~)设置内联查询。<br><br>你可以在任意笔记中使用下列语法创建JS dataview代码块：<br>```dataviewjs
... js code ...
```
复制<br>在JS dataview代码块里，你可以通过dv变量访问所有dataview的API。关于你能用它做什么，见<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/code-reference" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/code-reference" target="_self">API文档</a>，或<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/code-example" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/code-example" target="_self">API实例</a>。<br><br><br>dataview查询语言是一种简单的、结构化的、自定义的查询语言，用于快速创建数据的视图。支持：<br>
<br>提取与标签、文件夹、链接等相关的页面。
<br>通过对字段的简单操作过滤页面/数据，如比较、存在性检查等。
<br>根据字段对结果进行排序。
<br>该查询语言支持以下视图类型，描述如下：<br>
<br>表格(TABLE)：传统的视图类型；每个数据点为一行，字段数据为一列。
<br>列表(LIST)：匹配查询页面的列表。你可以为每个页面输出一个单一的关联值。
<br>任务列表(TASK)：匹配给定查询的任务列表。
<br><br>查询的通用格式如下：<br>```dataview
TABLE|LIST|TASK &lt;field&gt; [AS "Column Name"], &lt;field&gt;, ..., &lt;field&gt; FROM &lt;source&gt; (like #tag or "folder")
WHERE &lt;expression&gt; (like 'field = value')
SORT &lt;expression&gt; [ASC/DESC] (like 'field ASC')
... other data commands
```
复制<br>只有 "select "语句（描述什么视图和什么字段）是必需的。如果省略了FROM语句，会自动查询你在库中的所有markdown页面。如果其他语句（如WHERE或SORT）存在，它们将按照顺序运行。重复的语句是允许的（例如，多个WHERE语句）。<br>
<br>对于不同的视图类型，只有第一行（"select "部分，在这里你指定要显示的视图类型和字段）是不同的。你可以在任何查询中应用数据命令(data commands)&nbsp;如WHERE和SORT，你也可以通过使用FROM来选择<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/sources" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/sources" target="_self">来源</a>。
<br>关于什么是表达式见<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/393550306/expressions" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/p/393550306/expressions" target="_self">表达式</a>&nbsp;, 什么是来源见<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/393550306/sources" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/p/393550306/sources" target="_self">来源</a>。<br><br><br>列表是最简单的视图，它简单地呈现了一个匹配查询的页面（或自定义字段）的列表。 要获得与查询相匹配的页面的列表，只需使用：<br>LIST FROM &lt;source&gt;
复制<br>举个例子，运行list from #每天&nbsp;会呈现:<br><img alt="47d16b067f2f84e7c79aadb83c41dd22_MD5.png" src="https://pages-9hu.pages.dev/attachments/47d16b067f2f84e7c79aadb83c41dd22_md5.png" target="_self"><br>你可以通过在LIST后面添加一个表达式，在每个匹配的文件之外呈现一个单一的计算值。<br>LIST &lt;expression&gt; FROM &lt;source&gt;
复制<br>举个例子，运行list "文件：路径" + file.path from #每天&nbsp;会呈现:<br><img alt="1309ec9840f710780ad6719da4974ca1_MD5.webp" src="https://pages-9hu.pages.dev/attachments/1309ec9840f710780ad6719da4974ca1_md5.webp" style="width: 200px; max-width: 100%;" target="_self"><br><br>表格提供页面数据的表格化视图。你可以通过给出一个逗号分隔的YAML字段列表来构建一个表格，像这样：<br>TABLE file.cday, file.mtime FROM #每天
复制<br><img alt="afd0d28f373cd4e2165bbf4d0328de42_MD5.webp" src="https://pages-9hu.pages.dev/attachments/afd0d28f373cd4e2165bbf4d0328de42_md5.webp" target="_self"><br>你可以通过使用AS语法，选择一个标题名称来表示已计算的字段。<br>TABLE (file.mtime + dur(1 day)) AS next_mtime, ... FROM &lt;source&gt;
复制<br><img alt="cf9bd8939eb04173f0ab9f8e115a0d28_MD5.webp" src="https://pages-9hu.pages.dev/attachments/cf9bd8939eb04173f0ab9f8e115a0d28_md5.webp" target="_self"><br>一个表格查询的例子:<br>table 日期, 评级, 起床, 睡觉 from #每天 SORT 评级 DESC
复制<br><img alt="b8ea851750e0acba8bf831c6d1e7c490_MD5.webp" src="https://pages-9hu.pages.dev/attachments/b8ea851750e0acba8bf831c6d1e7c490_md5.webp" target="_self"><br><br>任务视图呈现所有其页面符合给定谓词的任务。<br>TASK from &lt;source&gt;
复制<br>举个例子,&nbsp;task from #task会呈现:<br><img alt="81849767c5ac1193f0034b33b6d00f0e_MD5.webp" src="https://pages-9hu.pages.dev/attachments/81849767c5ac1193f0034b33b6d00f0e_md5.webp" target="_self"><br><br>dataview查询可以由不同的命令组成。命令是按顺序执行的，你可以有重复的命令（例如，多个WHERE块或多个GROUP BY块）。<br><br>FROM语句决定了哪些页面在初始被收集并传递给其他命令进行进一步的筛选。你可以从任何<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/sources" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/sources" target="_self">来源</a>中选择，来源可选择文件夹，标签，内链和外链。<br>
<br>标签(Tags): 从标签(包含子标签)中选择，使用FROM #tag。
<br>文件夹(Folders): 从文件夹(包含子文件夹)中选择，使用&nbsp;FROM "folder"。
<br>链接(Links): 你可以选择一个链接到该文件的链接，也可以选择该文件链接到其它页面的链接：
<br>获得链接到[[note]]的所有页面，使用FROM [[note]]。
<br>获得从[[note]]链接的所有页面(如，文件中的所有链接)，使用FROM outgoing([[note]])。
<br>你可以对过滤器进行组合，以便使用 "and "和 "or "获得更高级的来源。 - 举个例子，#tag and "folder"将返回在folder中和包含#tag的所有页面。 -&nbsp;[[Food]] or [[Exercise]]&nbsp;将给出任何链接到[[Food]]或[[Exercise]]的页面。<br><br>根据字段过滤页面。只有clause计算为 "true "的页面才会被显示：<br>WHERE &lt;clause&gt;
复制<br>
<br>获得所有在最近24小时内修改的文件。
<br>LIST WHERE file.mtime &gt;= date(today) - dur(1 day)
复制<br>
<br>找到所有未标明完成且超过一个月的project。
<br>LIST FROM #projects
WHERE !completed AND file.ctime &lt;= date(today) - dur(1 month)
复制<br><br>按一个或多个字段对所有结果进行排序。<br>SORT date [ASCENDING/DESCENDING/ASC/DESC]
复制<br>你也可以给出多个字段来进行排序。排序将在第一个字段的基础上进行。接着，如果出现相等，第二个字段将被用来对相等的字段进行排序。如果仍然有相等，将用第三个字段进行排序，以此类推。<br>SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC]
复制<br><br>对一个字段的所有结果进行分组。每个唯一的字段值产生一行，它有两个属性：一个对应于被分组的字段，一个是rows数组字段，包含所有匹配的页面。<br>GROUP BY field
GROUP BY (computed_field) AS name
复制<br>为了使rows数组工作更容易，Dataview支持字段的 "调配(swizzling)"。如果你想从rows数组中的每个对象获取test字段，那么rows.test将自动从rows中的每个对象获取test字段，产生一个新的数组。 你可以在产生的数组上应用聚合运算符，如sum()。<br><br>对一个数组的每一行进行扁平化处理，在数组中的每个条目产生一个结果行。<br>FLATTEN field
FLATTEN (computed_field) AS name
复制<br>例如，将每个文献注释中的 "作者 "字段扁平化处理，使每个作者占一行。<br>table authors from #LiteratureNote
flatten authors
复制<br><img alt="4b762c1d08c86c8706cd6dab097d9a75_MD5.webp" src="https://pages-9hu.pages.dev/attachments/4b762c1d08c86c8706cd6dab097d9a75_md5.webp" target="_self"><br><br>Dataview查询语言表达式&nbsp;可以是任何能产生一个值的量，所有字段都是表达式，字面值如6，已计算的值如field - 9都是一个表达式，做一个更具体的总结：<br># 常规
field (directly refer to a field)
simple-field (refer to fields with spaces/punctuation in them like "Simple Field!")
a.b (if a is an object, retrieve field named 'b')
a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr')
f(a, b, ...) (call a function called `f` on arguments a, b, ...) # 算术运算
a + b (addition)
a - b (subtraction)
a * b (multiplication)
a / b (division) # 比较运算
a &gt; b (check if a is greater than b)
a &lt; b (check if a is less than b)
a = b (check if a equals b)
a != b (check if a does not equal b)
a &lt;= b (check if a is less than or equal to b)
a &gt;= b (check if a is greater than or equal to b) # 特殊操作
[[Link]].value (fetch `value` from page `Link`)
复制<br>下面是对每项内容的更详细阐述。<br><br><br>最简单的表达式是直接引用一个字段的表达式。如果你有一个叫做 "field "的字段，那么你可以直接引用它的名字 -&nbsp;field。如果字段名有空格、标点符号或其他非字母/数字的 字符，那么你可以使用Dataview的全小写且空格被替换为“-”简化名称来引用它。例如，this is a field变成this-is-a-field；Hello！变成hello，以此类推。<br><br>你可以使用标准算术运算符来组合字段：加法（+），减法（-），乘法（*）。 和除法 (/)。例如，field1 + field2是一个计算两个字段之和的表达式。<br><br>你可以使用各种比较运算符来比较大多数数值。&lt;,&nbsp;&gt;,&nbsp;&lt;=,&nbsp;&gt;=,&nbsp;=,&nbsp;!=. 这产生了一个布尔的真或假值，可以在查询中的`WHERE'块中使用。<br><br>你可以通过索引操作符array[&lt;index&gt;]从数组中索引数据，其中&lt;index&gt;是任何已计算的表达式。 数组是以0为索引的，所以第一个元素是索引0，第二个元素是索引1，以此类推。 例如，list(1, 2, 3)[0] = 1.<br>你也可以使用索引操作符从对象（将文本映射到数据值）中检索数据，此时的索引是字符串/文本而不是数字。你也可以使用快捷方式object.&lt;name&gt;，其中&lt;name&gt;是值的索引。例如object("yes", 1).yes = 1。<br><br>Dataview支持各种用于操作数据的函数，这些函数在<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/393550306/functions" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/p/393550306/functions" target="_self">函数文档</a>中有完整描述。它们的一般语法是function(arg1, arg2, ...)&nbsp;- 即lower("yes")或&nbsp;regexmatch("text", ".+")。<br><br><br>大多数dataview类型与运算符有特殊的相互作用，或者有额外的字段可以使用索引操作符索引。<br><br>你可以通过索引来检索一个日期的不同组成部分：date.year，date.month，date.day，date.hour。&nbsp;date.minute,&nbsp;date.second,&nbsp;date.week。你也可以将时间段添加到日期中以获得新的日期。<br><br>时间段可以相互添加，也可以添加到日期。你可以通过索引来检索一个时间段的各种组成部分。duration.years,&nbsp;duration.months,&nbsp;duration.days,&nbsp;duration.hours,&nbsp;duration.minutes,&nbsp;duration.seconds.<br><br>你可以 "通过索引 "一个链接来获得相应页面上的值。例如，[[Link]].value将获得来自Link页面上的value值。<br><br>dataview中的来源指的是标识一组文件，任务或者其它数据对象的东西。来源是由dataview内部索引的，所以可以快速进行查询。dataview目前支持三种来源类型：<br>
<br>标签(Tages)：格式为#tag的来源。
<br>文件夹(Folders)：格式为“folder”的来源。
<br>链接(Links)：你可以选择内链和外链。 <br>获得链接到[[note]]的所有页面，使用FROM [[note]]。 <br>获得从[[note]]链接的所有页面(如，文件中的所有链接)，使用FROM outgoing([[note]])。
<br>你可以对这些过滤器进行组合，以便使用 "and "和 "or "获得更高级的来源。<br>
<br>举个例子，#tag和 "folder"将返回在folder中和包含#tag的所有页面。
<br>[[Food]] or [[Exercise]]&nbsp;将给出任何链接到[[Food]]或[[Exercise]]的所有页面。
<br>来源既用于<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/queries#from" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/queries#from" target="_self">FROM查询语句</a>，也用于各种JavaScript API查询调用。<br><br>dataview的函数提供了更高级操作数据的方法。<br><br>大多数函数可以应用于单个值（如数字，字符串，日期等）或这些值的列表。如果一个函数被应用于一个列表，在函数被应用于列表中的每个元素后，它也会返回一个列表。如：<br>lower("YES") = "yes"
lower(list("YES", "NO")) = list("yes", "no") replace("yes", "e", "a") = "yas"
replace(list("yes", "ree"), "e", "a") = list("yas", "raa")
复制<br><br>构造器创建值<br><br>用给定的键和值创建一个新的对象。在调用中，键和值应该交替出现，键应该总是字符串/文本。<br>object() =&gt; empty object
object("a", 6) =&gt; object which maps "a" to 6
object("a", 4, "c", "yes") =&gt; object which maps a to 4, and c to "yes"
复制<br><br>用给定的值创建一个新的列表。<br>list() =&gt; empty list
list(1, 2, 3) =&gt; list with 1, 2, and 3
list("a", "b", "c") =&gt; list with "a", "b", and "c"
复制<br><br>从提供的字符串、日期或链接对象中解析一个日期，解析不出返回null。<br>date("2020-04-18") = &lt;date object representing April 18th, 2020&gt;
date([[2021-04-16]]) = &lt;date object for the given page, refering to file.day&gt;
复制<br><br>从给定的字符串中抽出第一个数字，并返回该数字。如果字符串中没有数字，则返回null。<br>number("18 years") = 18
number(34) = 34
number("hmm") = null
复制<br><br>从给定的文件路径或名称构建一个链接对象。如果有两个参数，第二个参数是链接的显示名称。<br>link("Hello") =&gt; link to page named 'Hello'
link("Hello", "Goodbye") =&gt; link to page named 'Hello', displays as 'Goodbye'
复制<br><br>构建一个指向外部网址的链接（如www.google.com）。如果有两个参数，第二个参数是该链接的显示名称。<br>elink("www.google.com") =&gt; link element to google.com
elink("www.google.com", "Google") =&gt; link element to google.com, displays as "Google"
复制<br><br><br><br>将一个数字四舍五入到指定的位数。如果没有指定第二个参数，则舍入到最接近的整数。 否则，四舍五入到给定的位数。<br>round(16.555555) = 17
round(16.555555, 2) = 16.56
复制<br>--<br><br>对容器对象内部的值进行操作的操作。<br><br>检查给定的容器类型中是否有给定的值。这个函数的行为稍有不同，它基于第一个参数是一个对象，一个列表，还是一个字符串。<br>
<br>对于对象，检查该对象是否有一个给定名称的键。如：&nbsp;contains(file, "ctime") = true contains(file, "day") = true (if file has a date in its title, false otherwise)
<br>对于列表，检查数组中是否有元素等于给定的值。如：&nbsp;contains(list(1, 2, 3), 3) = true contains(list(), 1) = false
<br>对于字符串，检查给定的值是否是字符串的子串。&nbsp;contains("hello", "lo") = true contains("yes", "no") = false
<br><br>从一个对象中抽出多个字段，创建一个抽出字段的新对象。<br>extract(file, "ctime", "mtime") = object("ctime", file.ctime, "mtime", file.mtime)
extract(object("test", 1)) = object()
复制<br><br>排序列表，返回一个排序好的新列表。<br>sort(list(3, 2, 1)) = list(1, 2, 3)
sort(list("a", "b", "aa")) = list("a", "aa", "b")
复制<br><br>反转列表，返回一个反转好的新列表。<br>reverse(list(1, 2, 3)) = list(3, 2, 1)
reverse(list("a", "b", "c")) = list("c", "b", "a")
复制<br><br>返回一个对象中的字段数量，或一个数组中的元素数量。<br>length(list()) = 0
length(list(1, 2, 3)) = 3
length(object("hello", 1, "goodbye", 2)) = 2
复制<br><br>数组中数值元素求和。<br>sum(list(1, 2, 3)) = 6
复制<br><br>只有当数组中的所有值都为真，才会返回 "true"。你也可以给这个函数传递多个参数，只有当所有的参数都为真时，它才会返回`true'。<br>all(list(1, 2, 3)) = true
all(list(true, false)) = false
all(true, false) = false
all(true, true, true) = true
复制<br><br>只要数组中有值为真，便返回true。也可以给这个函数传递多个参数，只要有参数为真，便返回true。<br>any(list(1, 2, 3)) = true
any(list(true, false)) = true
any(list(false, false, false)) = false
all(true, false) = true
all(false, false) = false
复制<br><br>如果数组中没有元素，返回none。<br><br>将一个数组中的元素连接成一个字符串（即在同一行呈现所有的元素）。如果有第二个参数，那么每个元素将被给定的分隔符分开。<br>join(list(1, 2, 3)) = "1, 2, 3"
join(list(1, 2, 3), " ") = "1 2 3"
join(6) = "6"
join(list()) = ""
复制<br><br><br><br>检查给定的字符串是否与给定的模式相匹配（使用JavaScript regex引擎）。<br>regexmatch("\w+", "hello") = true
regexmatch(".", "a") = true
regexmatch("yes|no", "maybe") = false
复制<br><br>用 "replacement "替换所有在 "string "中匹配regex&nbsp;pattern的实例。这使用了JavaScript的替换方法，所以你可以使用特殊字符如$1来指代第一个捕获组，以此类推。<br>regexreplace("yes", "[ys]", "a") = "aea"
regexreplace("Suite 1000", "\d+", "-") = "Suite -"
复制<br><br>用replacement替换string中的所有pattern实例。<br>replace("what", "wh", "h") = "hat"
replace("The big dog chased the big cat.", "big", "small") = "The small dog chased the small cat."
replace("test", "test", "no") = "no"
复制<br><br>将一个字符串所有字符转换为小写字符。<br>lower("Test") = "test"
lower("TEST") = "test"
复制<br><br>将一个字符串所有字符转换为大写字符。<br>upper("Test") = "TEST"
upper("test") = "TEST"
复制<br><br><br>如果field为空，返回value；否则返回field。对于用默认值替换空值很有用。例如，要显示尚未完成的项目，使用"incomplete"作为其默认值。<br>default(dateCompleted, "incomplete")
复制<br>默认值在两个参数中都是矢量；如果你需要在一个列表参数中明确使用默认值，请使用ldefault，它与默认值相同，但没有被矢量化。<br>default(list(1, 2, null), 3) = list(1, 2, 3)
ldefault(list(1, 2, null), 3) = list(1, 2, null)
复制<br><br>一个原始的if语句--如果第一个参数为真，则返回第二个参数的内容；否则，返回第三个参数的内容。<br>choice(true, "yes", "no") = "yes"
choice(false, "yes", "no") = "no"
choice(x &gt; 4, y, z) = y if x &gt; 4, else z
复制<br><br>剥离日期中的时间部分，只留下年、月、日。如果你在比较日期的时候不在乎时间，这种方式挺好。<br>striptime(file.ctime) = file.cday
striptime(file.mtime) = file.mday
复制<br><br>一个简单的dataview查询语言使用的小集合。<br>利用一些元数据，显示所有games文件夹下的文件，按评分排序：<br>```dataview
TABLE time-played, length, rating FROM "games"
SORT rating DESC
```
复制<br><img alt="d05d38c1e6e1890524c2419bafb53efe_MD5.webp" src="https://pages-9hu.pages.dev/attachments/d05d38c1e6e1890524c2419bafb53efe_md5.webp" target="_self"><br>列表列举所有MOBA游戏或CRPG游戏：<br>```dataview
LIST FROM #game/moba or #game/crpg
```
复制<br><img alt="dd570926472857b086e0c08aaff00994_MD5.webp" src="https://pages-9hu.pages.dev/attachments/dd570926472857b086e0c08aaff00994_md5.webp" target="_self"><br>任务列表列举所有未完成项目的<br>```dataview
TASK FROM #projects/active
```
复制<br><img alt="84d21c732ade3711f9fb63c530c15865_MD5.webp" src="https://pages-9hu.pages.dev/attachments/84d21c732ade3711f9fb63c530c15865_md5.webp" target="_self"><br>表格列举所有在books文件夹下的文件，按最后编辑时间排序：<br>```dataview
TABLE file.mtime FROM "books"
SORT file.mtime DESC
```
复制<br>列表列举所有标题中有日期的文件(格式为yyyy-mm-dd)，按日期排序：<br>```dataview
LIST file.day WHERE file.day
SORT file.day DESC
```
复制<br><br><br>dataview的JavaScript API允许执行任意的JavaScript，可以访问dataview的索引和查询引擎。引擎，这对于复杂的视图或与其他插件的互操作是很好的。该API有两种形式：面向插件和面向用户（或 "内联API使用方式"）。面向插件的方式目前还不能使用，所以本文档将专注于面向用户的查询，任意的JS都可以在markdown页面中执行。<br><br>你可以通过下述操作创建一个Dataview JS代码块：<br>```dataviewjs
&lt;code&gt;
```
复制<br>在这种代码块中执行的代码可以访问dv变量，它提供了与代码块相关的全部dataview API（如dv.table()，dv.pages()，等等）。更多信息，请查看<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/code-reference" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/code-reference" target="_self">代码块API参考</a>。<br><br>在Dataview中，列表的结果一般抽象为DataArray，它是一个具有额外功能的代理数组。数据数组支持就像普通数组一样索引和迭代（通过 "for "和 "for ... of "循环），但也包括许多数据操作符，如 "sort"、"groupBy"、"distinct"、"where "等，使表格数据的处理变得简单。<br><br>数据数组是大部分情况是由可以返回多个结果的Dataview API返回的，比如dv.pages()。你也可以使用dv.array(&lt;array&gt;)明确地将一个普通的JavaScript数组转换成Dataview数组。如果你想把一个数据数组转换为普通数组，请使用DataArray#array()。<br><br>数据数组像普通数组一样支持常规索引（如array[0]），但重要的是，它还支持查询语言风格的 "swizzling"：如果你用字段名索引到一个数据数组（如array.field），它会自动将数组中的每个元素映射到field，如果field本身也是一个数组，则会将其扁平化。<br>例如，dv.pages().file.name将返回库中所有包含文件名的数据数组。&nbsp;dv.pages("#books").genres将返回books中所有类型的扁平化列表。<br><br>下面提供了数据数组实现的完整接口以供参考。<br>/** A function which maps an array element to some value. */
export type ArrayFunc&lt;T, O&gt; = (elem: T, index: number, arr: T[]) =&gt; O; /** A function which compares two types (plus their indices, if relevant). */
export type ArrayComparator&lt;T&gt; = (a: T, b: T) =&gt; number; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */
export interface DataArray&lt;T&gt; { /** The total number of elements in the array. */ length: number; /** Filter the data array down to just elements which match the given predicate. */ where(predicate: ArrayFunc&lt;T, boolean&gt;): DataArray&lt;T&gt;; /** Alias for 'where' for people who want array semantics. */ filter(predicate: ArrayFunc&lt;T, boolean&gt;): DataArray&lt;T&gt;; /** Map elements in the data array by applying a function to each. */ map&lt;U&gt;(f: ArrayFunc&lt;T, U&gt;): DataArray&lt;U&gt;; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap&lt;U&gt;(f: ArrayFunc&lt;T, U[]&gt;): DataArray&lt;U&gt;; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate(f: ArrayFunc&lt;T, any&gt;): DataArray&lt;any&gt;; /** Limit the total number of entries in the array to the given value. */ limit(count: number): DataArray&lt;T&gt;; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice(start?: number, end?: number): DataArray&lt;T&gt;; /** Concatenate the values in this data array with those of another data array. */ concat(other: DataArray&lt;T&gt;): DataArray&lt;T&gt;; /** Return the first index of the given (optionally starting the search) */ indexOf(element: T, fromIndex?: number): number; /** Return the first element that satisfies the given predicate. */ find(pred: ArrayFunc&lt;T, boolean&gt;): T | undefined; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex(pred: ArrayFunc&lt;T, boolean&gt;): number; /** Returns true if the array contains the given element, and false otherwise. */ includes(element: T): boolean; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort&lt;U&gt;(key: ArrayFunc&lt;T, U&gt;, direction?: 'asc' | 'desc', comparator?: ArrayComparator&lt;U&gt;): DataArray&lt;T&gt;; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: &lt;key value&gt;, rows: DataArray }. */ groupBy&lt;U&gt;(key: ArrayFunc&lt;T, U&gt;, comparator?: ArrayComparator&lt;U&gt;): DataArray&lt;{ key: U, rows: DataArray&lt;T&gt; }&gt;; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct&lt;U&gt;(key?: ArrayFunc&lt;T, U&gt;, comparator?: ArrayComparator&lt;U&gt;): DataArray&lt;T&gt;; /** Return true if the predicate is true for all values. */ every(f: ArrayFunc&lt;T, boolean&gt;): boolean; /** Return true if the predicate is true for at least one value. */ some(f: ArrayFunc&lt;T, boolean&gt;): boolean; /** Return true if the predicate is FALSE for all values. */ none(f: ArrayFunc&lt;T, boolean&gt;): boolean; /** Return the first element in the data array. Returns undefined if the array is empty. */ first(): T; /** Return the last element in the data array. Returns undefined if the array is empty. */ last(): T; /** Map every element in this data array to the given key, and then flatten it.*/ to(key: string): DataArray&lt;any&gt;; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand(key: string): DataArray&lt;any&gt;; /** Run a lambda on each element in the array. */ forEach(f: ArrayFunc&lt;T, void&gt;): void; /** Convert this to a plain javascript array. */ array(): T[]; /** Allow iterating directly over the array. */ [Symbol.iterator](): Iterator&lt;T&gt;; /** Map indexes to values. */ [index: number]: any; /** Automatic flattening of fields. */ [field: string]: any;
}
复制<br><br>Dataview JavaScript Codeblocks是使用dataviewjs语言规范创建的一个代码块。<br>```dataviewjs
dv.table([], ...)
```
复制<br>API是通过隐含提供的dv（或dataview）变量来实现的，通过它可以查询信息，渲染HTML，并配置视图。<br><br><br>获取脚本当前执行的页面信息（dv.page()）。<br><br>接受一个字符串参数，source，与<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/query/sources" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/query/sources" target="_self">查询语言来源</a>的形式相同。返回一个<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/data-array" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/data-array" target="_self">数据数组</a>的页面对象，它是以所有页面字段为值的普通对象。<br>dv.pages("#books") =&gt; all pages with tag 'books'
dv.pages('"folder"') =&gt; all pages from folder "folder"
dv.pages("#yes or -#no") =&gt; all pages with tag #yes, or which DON'T have tag #no
复制<br><br>和dv.pages一样，但只是返回一个<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/docs/api/data-array" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/docs/api/data-array" target="_self">数据数组</a>，其中包括符合给定来源的页面路径。<br>dv.pagePaths("#books") =&gt; the paths of pages with tag 'books'
复制<br><br>将一个简单的路径映射到完整的页面对象，其中包括所有的页面字段。自动进行链接解析，如果不存在，会自动进行扩展。<br>dv.page("Index") =&gt; The page object for /Index
dv.page("books/The Raisin.md") =&gt; The page object for /books/The Raisin.md
复制<br><br><br>用给定的文本渲染1 - 6级标题。<br>dv.header(1, "Big!");
dv.header(6, "Tiny");
复制<br><br>在段落中渲染任意文本。<br>dv.paragraph("This is some text");
复制<br><br><br>渲染一个dataview的元素列表；接受vanilla数组和数据数组。<br>dv.list([1, 2, 3]) =&gt; list of 1, 2, 3
dv.list(dv.pages().file.name) =&gt; list of all file names
dv.list(dv.pages().file.link) =&gt; list of all file links
dv.list(dv.pages("#book").where(p =&gt; p.rating &gt; 7)) =&gt; list of all books with rating greater than 7
复制<br><br>渲染一个由page.file.tasks获得的Task对象的dataview任务列表。第一个参数是必需的；如果提供第二个参数groupByFile(须为真)，那么将会按照文件的来源对任务列表进行分组。<br>// List all tasks from pages marked '#project'
dv.taskList(dv.pages("#project").file.tasks) // List all *uncompleted* tasks from pages marked #project
dv.taskList(dv.pages("#project").file.tasks .where(t =&gt; !t.completed)) // List all tasks tagged with '#tag' from pages marked #project
dv.taskList(dv.pages("#project").file.tasks .where(t =&gt; t.text.includes("#tag")))
复制<br><br>用给定的标题列表和2维数组渲染一个dataview表格。<br>// Render a simple table of book info sorted by rating.
dv.table(["File", "Genre", "Time Read", "Rating"], dv.pages("#book") .sort(b =&gt; b.rating) .map(b =&gt; [b.file.link, b.genre, b["time-read"], b.rating]))
复制<br><br><br>将一个给定的值或数组转换成Dataview&nbsp;<a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/393550306/data-array" rel="noopener" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/p/393550306/data-array" target="_self">数据数组</a>。如果该值已经是一个数据数组，则返回它，不作任何改变。<br>dv.array([1, 2, 3]) =&gt; dataview data array [1, 2, 3]
复制<br><br>根据dataview的默认比较规则，比较两个任意的JavaScript值；如果你打算写一个自定义的比较器并且不想影响正常代码，那非常有用。如果a &lt; b返回-1，如果a = b返回0，如果a &gt; b返回1。<br>dv.compare(1, 2) = -1
dv.compare("yes", "no") = 1
dv.compare({ what: 0 }, { what: 0 }) = 0
复制<br><br>比较两个任意的JavaScript值，如果根据Dataview的默认比较规则是相等的，则返回true。<br>dv.equal(1, 2) = false
dv.equal(1, 1) = true
复制<br><br><br>按体裁对你的书籍进行分组，然后为每本书创建一个按评级分类的表格。<br>for (let group of dv.pages("#book").groupBy(p =&gt; p.genre)) { dv.header(3, group.key); dv.table(["Name", "Time Read", "Rating"], group.rows .sort(k =&gt; k.rating, 'desc') .map(k =&gt; [k.file.link, k["time-read"], k.rating]))
}
复制<br><img alt="c0297ff470a95934db5b2a392d39d70e_MD5.webp" src="https://pages-9hu.pages.dev/attachments/c0297ff470a95934db5b2a392d39d70e_md5.webp" target="_self">]]></description><link>https://pages-9hu.pages.dev/知识库/日常技能/obsidian/dataview官方文档.html</link><guid isPermaLink="false">知识库/日常技能/Obsidian/dataview官方文档.md</guid><pubDate>Mon, 17 Jun 2024 17:11:28 GMT</pubDate><enclosure url="https://pages-9hu.pages.dev/attachments/e8a1c69fde1cdafa3fe4964213644b3e_md5.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://pages-9hu.pages.dev/attachments/e8a1c69fde1cdafa3fe4964213644b3e_md5.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[汇总]]></title><description><![CDATA[<br><br>]]></description><link>https://pages-9hu.pages.dev/知识库/汇总.html</link><guid isPermaLink="false">知识库/汇总.md</guid><pubDate>Mon, 17 Jun 2024 17:01:34 GMT</pubDate></item><item><title><![CDATA[20240616]]></title><description><![CDATA[<br><br>nothing<br><br>
<br>骑车34KM
<br>学会了Obsidian
<br>建立知识库
]]></description><link>https://pages-9hu.pages.dev/日记/2024年06月记录.html</link><guid isPermaLink="false">日记/2024年06月记录.md</guid><pubDate>Mon, 17 Jun 2024 14:56:29 GMT</pubDate></item></channel></rss>